
//----------------------------------------------------
// The following code was generated by CUP v0.11a beta 20060608
// Sat Sep 12 17:14:17 CEST 2020
//----------------------------------------------------

package compiler.syntax;

import java_cup.runtime.Symbol;
import java.util.*;
import es.uned.lsi.compiler.lexical.*;
import es.uned.lsi.compiler.code.*;
import es.uned.lsi.compiler.intermediate.*;
import es.uned.lsi.compiler.semantic.*;
import es.uned.lsi.compiler.semantic.symbol.*;
import es.uned.lsi.compiler.semantic.type.*;
import es.uned.lsi.compiler.syntax.*;
import compiler.CompilerContext;
import compiler.lexical.*;
import compiler.syntax.nonTerminal.*;
import compiler.semantic.*;
import compiler.semantic.symbol.*;
import compiler.semantic.type.*;
import compiler.intermediate.*;
import compiler.code.*;

/** CUP v0.11a beta 20060608 generated parser.
  * @version Sat Sep 12 17:14:17 CEST 2020
  */
public class parser extends java_cup.runtime.lr_parser {

  /** Default constructor. */
  public parser() {super();}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}

  /** Production table. */
  protected static final short _production_table[][] = 
    unpackFromStrings(new String[] {
    "\000\157\000\002\002\004\000\002\056\002\000\002\002" +
    "\004\000\002\003\004\000\002\003\004\000\002\004\005" +
    "\000\002\004\004\000\002\005\013\000\002\005\012\000" +
    "\002\005\010\000\002\006\004\000\002\006\002\000\002" +
    "\006\004\000\002\012\004\000\002\012\003\000\002\013" +
    "\006\000\002\013\005\000\002\014\003\000\002\014\003" +
    "\000\002\007\004\000\002\007\002\000\002\007\004\000" +
    "\002\015\004\000\002\015\003\000\002\016\015\000\002" +
    "\016\005\000\002\010\004\000\002\010\002\000\002\010" +
    "\004\000\002\017\004\000\002\017\003\000\002\020\006" +
    "\000\002\020\005\000\002\021\005\000\002\021\003\000" +
    "\002\022\003\000\002\022\003\000\002\011\005\000\002" +
    "\011\002\000\002\023\007\000\002\023\005\000\002\023" +
    "\004\000\002\025\005\000\002\025\002\000\002\026\005" +
    "\000\002\026\003\000\002\026\002\000\002\027\005\000" +
    "\002\027\005\000\002\024\004\000\002\024\002\000\002" +
    "\024\005\000\002\033\003\000\002\033\003\000\002\033" +
    "\005\000\002\033\003\000\002\034\005\000\002\034\005" +
    "\000\002\034\003\000\002\035\005\000\002\035\005\000" +
    "\002\035\005\000\002\035\004\000\002\035\003\000\002" +
    "\030\004\000\002\030\003\000\002\030\002\000\002\031" +
    "\005\000\002\031\003\000\002\032\003\000\002\032\003" +
    "\000\002\032\003\000\002\032\003\000\002\032\003\000" +
    "\002\032\003\000\002\032\003\000\002\032\003\000\002" +
    "\043\004\000\002\043\005\000\002\042\005\000\002\042" +
    "\005\000\002\044\010\000\002\044\005\000\002\044\005" +
    "\000\002\045\004\000\002\045\002\000\002\046\013\000" +
    "\002\046\012\000\002\046\005\000\002\037\003\000\002" +
    "\037\004\000\002\040\005\000\002\040\004\000\002\040" +
    "\004\000\002\041\005\000\002\041\003\000\002\047\006" +
    "\000\002\047\005\000\002\050\006\000\002\050\005\000" +
    "\002\051\003\000\002\036\003\000\002\036\004\000\002" +
    "\036\004\000\002\052\005\000\002\053\003\000\002\053" +
    "\003\000\002\054\003\000\002\054\003\000\002\055\003" +
    "\000\002\055\003" });

  /** Access to production table. */
  public short[][] production_table() {return _production_table;}

  /** Parse-action table. */
  protected static final short[][] _action_table = 
    unpackFromStrings(new String[] {
    "\000\303\000\004\012\000\001\002\000\004\002\305\001" +
    "\002\000\004\012\007\001\002\000\004\002\uffff\001\002" +
    "\000\006\003\302\004\303\001\002\000\016\003\013\013" +
    "\ufff6\015\ufff6\021\011\022\ufff6\023\ufff6\001\002\000\006" +
    "\003\267\004\270\001\002\000\004\002\ufffe\001\002\000" +
    "\004\002\ufffd\001\002\000\012\013\uffed\015\uffed\022\016" +
    "\023\uffed\001\002\000\010\013\uffe6\015\uffe6\023\044\001" +
    "\002\000\006\003\017\004\020\001\002\000\010\013\uffec" +
    "\015\uffec\023\uffec\001\002\000\006\003\024\045\025\001" +
    "\002\000\012\004\uffea\013\uffea\015\uffea\023\uffea\001\002" +
    "\000\012\004\020\013\uffee\015\uffee\023\uffee\001\002\000" +
    "\012\004\uffeb\013\uffeb\015\uffeb\023\uffeb\001\002\000\004" +
    "\043\043\001\002\000\004\010\026\001\002\000\004\037" +
    "\027\001\002\000\006\004\030\052\032\001\002\000\006" +
    "\040\uff95\041\uff95\001\002\000\004\041\033\001\002\000" +
    "\006\040\uff96\041\uff96\001\002\000\006\004\030\052\032" +
    "\001\002\000\004\040\035\001\002\000\004\011\036\001" +
    "\002\000\006\005\037\006\041\001\002\000\006\036\uff98" +
    "\043\uff98\001\002\000\004\043\042\001\002\000\006\036" +
    "\uff97\043\uff97\001\002\000\012\004\uffe9\013\uffe9\015\uffe9" +
    "\023\uffe9\001\002\000\012\004\uffe8\013\uffe8\015\uffe8\023" +
    "\uffe8\001\002\000\006\003\255\004\240\001\002\000\006" +
    "\013\uffdb\015\046\001\002\000\006\003\222\004\223\001" +
    "\002\000\014\013\ufff6\015\ufff6\021\011\022\ufff6\023\ufff6" +
    "\001\002\000\004\013\051\001\002\000\024\003\071\004" +
    "\073\014\uffbf\016\057\024\063\030\075\032\052\033\070" +
    "\034\055\001\002\000\006\003\214\035\213\001\002\000" +
    "\010\014\uffb8\025\uffb8\043\uffb8\001\002\000\004\014\207" +
    "\001\002\000\010\014\uff9d\025\uff9d\043\uff9d\001\002\000" +
    "\010\014\uffb5\025\uffb5\043\uffb5\001\002\000\020\003\205" +
    "\004\112\020\110\035\103\052\101\053\102\054\104\001" +
    "\002\000\010\014\uffb6\025\uffb6\043\uffb6\001\002\000\006" +
    "\003\200\051\201\001\002\000\010\014\uffc0\025\uffc0\043" +
    "\176\001\002\000\020\003\165\004\112\020\110\035\103" +
    "\052\101\053\102\054\104\001\002\000\010\014\uffbc\025" +
    "\uffbc\043\uffbc\001\002\000\010\014\uffbd\025\uffbd\043\uffbd" +
    "\001\002\000\010\014\uffbb\025\uffbb\043\uffbb\001\002\000" +
    "\010\014\uffba\025\uffba\043\uffba\001\002\000\006\003\157" +
    "\035\160\001\002\000\010\002\ufff8\013\ufff8\015\ufff8\001" +
    "\002\000\010\014\uffb7\025\uffb7\043\uffb7\001\002\000\020" +
    "\003\uff9c\014\uffa8\025\uffa8\035\115\037\114\043\uffa8\051" +
    "\uff9c\001\002\000\010\014\uffb9\025\uffb9\043\uffb9\001\002" +
    "\000\006\003\076\004\077\001\002\000\004\043\155\001" +
    "\002\000\004\051\100\001\002\000\016\004\112\020\110" +
    "\035\103\052\101\053\102\054\104\001\002\000\040\003" +
    "\uffc7\014\uffc7\017\uffc7\025\uffc7\026\uffc7\027\uffc7\031\uffc7" +
    "\036\uffc7\040\uffc7\042\uffc7\043\uffc7\045\uffc7\046\uffc7\047" +
    "\uffc7\050\uffc7\001\002\000\040\003\uff94\014\uff94\017\uff94" +
    "\025\uff94\026\uff94\027\uff94\031\uff94\036\uff94\040\uff94\042" +
    "\uff94\043\uff94\045\uff94\046\uff94\047\uff94\050\uff94\001\002" +
    "\000\016\004\112\020\110\035\103\052\101\053\102\054" +
    "\104\001\002\000\040\003\uff93\014\uff93\017\uff93\025\uff93" +
    "\026\uff93\027\uff93\031\uff93\036\uff93\040\uff93\042\uff93\043" +
    "\uff93\045\uff93\046\uff93\047\uff93\050\uff93\001\002\000\016" +
    "\017\133\031\144\045\127\046\130\047\132\050\131\001" +
    "\002\000\040\003\uffc2\014\uffc2\017\uffc2\025\uffc2\026\uffc2" +
    "\027\uffc2\031\uffc2\036\uffc2\040\uffc2\042\uffc2\043\uffc2\045" +
    "\uffc2\046\uffc2\047\uffc2\050\uffc2\001\002\000\040\003\uffcd" +
    "\014\uffcd\017\uffcd\025\uffcd\026\uffcd\027\uffcd\031\uffcd\036" +
    "\uffcd\040\uffcd\042\uffcd\043\uffcd\045\uffcd\046\uffcd\047\uffcd" +
    "\050\uffcd\001\002\000\016\004\112\020\110\035\103\052" +
    "\101\053\102\054\104\001\002\000\040\003\uffca\014\uffca" +
    "\017\uffca\025\uffca\026\uffca\027\uffca\031\uffca\036\uffca\040" +
    "\uffca\042\uffca\043\uffca\045\uffca\046\uffca\047\uffca\050\uffca" +
    "\001\002\000\044\003\uff9c\014\uff9c\017\uff9c\025\uff9c\026" +
    "\uff9c\027\uff9c\031\uff9c\035\115\036\uff9c\037\114\040\uff9c" +
    "\042\uff9c\043\uff9c\045\uff9c\046\uff9c\047\uff9c\050\uff9c\001" +
    "\002\000\040\003\uffcc\014\uffcc\017\uffcc\025\uffcc\026\uffcc" +
    "\027\uffcc\031\uffcc\036\uffcc\040\uffcc\042\uffcc\043\uffcc\045" +
    "\uffcc\046\uffcc\047\uffcc\050\uffcc\001\002\000\016\004\112" +
    "\020\110\035\103\052\101\053\102\054\104\001\002\000" +
    "\022\003\121\004\112\020\110\035\103\036\123\052\101" +
    "\053\102\054\104\001\002\000\042\003\uff9b\014\uff9b\017" +
    "\uff9b\025\uff9b\026\uff9b\027\uff9b\031\uff9b\036\uff9b\040\uff9b" +
    "\042\uff9b\043\uff9b\045\uff9b\046\uff9b\047\uff9b\050\uff9b\051" +
    "\uff9b\001\002\000\040\003\uff9a\014\uff9a\017\uff9a\025\uff9a" +
    "\026\uff9a\027\uff9a\031\uff9a\036\uff9a\040\uff9a\042\uff9a\043" +
    "\uff9a\045\uff9a\046\uff9a\047\uff9a\050\uff9a\001\002\000\020" +
    "\017\133\036\uffa2\042\uffa2\045\127\046\130\047\132\050" +
    "\131\001\002\000\042\003\uffa4\014\uffa4\017\uffa4\025\uffa4" +
    "\026\uffa4\027\uffa4\031\uffa4\036\uffa4\040\uffa4\042\uffa4\043" +
    "\uffa4\045\uffa4\046\uffa4\047\uffa4\050\uffa4\051\uffa4\001\002" +
    "\000\006\036\125\042\124\001\002\000\042\003\uffa5\014" +
    "\uffa5\017\uffa5\025\uffa5\026\uffa5\027\uffa5\031\uffa5\036\uffa5" +
    "\040\uffa5\042\uffa5\043\uffa5\045\uffa5\046\uffa5\047\uffa5\050" +
    "\uffa5\051\uffa5\001\002\000\016\004\112\020\110\035\103" +
    "\052\101\053\102\054\104\001\002\000\042\003\uffa6\014" +
    "\uffa6\017\uffa6\025\uffa6\026\uffa6\027\uffa6\031\uffa6\036\uffa6" +
    "\040\uffa6\042\uffa6\043\uffa6\045\uffa6\046\uffa6\047\uffa6\050" +
    "\uffa6\051\uffa6\001\002\000\020\017\133\036\uffa3\042\uffa3" +
    "\045\127\046\130\047\132\050\131\001\002\000\016\004" +
    "\112\020\110\035\103\052\101\053\102\054\104\001\002" +
    "\000\016\004\112\020\110\035\103\052\101\053\102\054" +
    "\104\001\002\000\016\004\112\020\110\035\103\052\101" +
    "\053\102\054\104\001\002\000\016\004\112\020\110\035" +
    "\103\052\101\053\102\054\104\001\002\000\016\004\112" +
    "\020\110\035\103\052\101\053\102\054\104\001\002\000" +
    "\040\003\uffc4\014\uffc4\017\uffc4\025\uffc4\026\uffc4\027\uffc4" +
    "\031\uffc4\036\uffc4\040\uffc4\042\uffc4\043\uffc4\045\uffc4\046" +
    "\uffc4\047\132\050\uffc4\001\002\000\040\003\uffc8\014\uffc8" +
    "\017\uffc8\025\uffc8\026\uffc8\027\uffc8\031\uffc8\036\uffc8\040" +
    "\uffc8\042\uffc8\043\uffc8\045\uffc8\046\uffc8\047\uffc8\050\uffc8" +
    "\001\002\000\034\003\uffc6\014\uffc6\017\133\025\uffc6\026" +
    "\uffc6\027\uffc6\031\uffc6\036\uffc6\040\uffc6\042\uffc6\043\uffc6" +
    "\046\130\047\132\001\002\000\040\003\uffc9\014\uffc9\017" +
    "\uffc9\025\uffc9\026\uffc9\027\uffc9\031\uffc9\036\uffc9\040\uffc9" +
    "\042\uffc9\043\uffc9\045\uffc9\046\uffc9\047\132\050\uffc9\001" +
    "\002\000\034\003\uffc5\014\uffc5\017\133\025\uffc5\026\uffc5" +
    "\027\uffc5\031\uffc5\036\uffc5\040\uffc5\042\uffc5\043\uffc5\046" +
    "\130\047\132\001\002\000\016\017\133\040\142\045\127" +
    "\046\130\047\132\050\131\001\002\000\042\003\uff99\014" +
    "\uff99\017\uff99\025\uff99\026\uff99\027\uff99\031\uff99\036\uff99" +
    "\040\uff99\042\uff99\043\uff99\045\uff99\046\uff99\047\uff99\050" +
    "\uff99\051\uff99\001\002\000\040\003\uffc3\014\uffc3\017\uffc3" +
    "\025\uffc3\026\uffc3\027\uffc3\031\uffc3\036\uffc3\040\uffc3\042" +
    "\uffc3\043\uffc3\045\uffc3\046\uffc3\047\uffc3\050\uffc3\001\002" +
    "\000\016\004\112\020\110\035\103\052\101\053\102\054" +
    "\104\001\002\000\020\003\147\017\133\027\146\045\127" +
    "\046\130\047\132\050\131\001\002\000\022\004\073\014" +
    "\uffbf\016\057\024\063\030\075\032\052\033\070\034\055" +
    "\001\002\000\004\043\150\001\002\000\010\014\uffaa\025" +
    "\uffaa\043\uffaa\001\002\000\004\014\152\001\002\000\010" +
    "\014\uffab\025\uffab\043\uffab\001\002\000\016\017\133\036" +
    "\154\045\127\046\130\047\132\050\131\001\002\000\040" +
    "\003\uffcb\014\uffcb\017\uffcb\025\uffcb\026\uffcb\027\uffcb\031" +
    "\uffcb\036\uffcb\040\uffcb\042\uffcb\043\uffcb\045\uffcb\046\uffcb" +
    "\047\uffcb\050\uffcb\001\002\000\010\014\uffa9\025\uffa9\043" +
    "\uffa9\001\002\000\014\003\uff9a\014\uffa7\025\uffa7\043\uffa7" +
    "\051\uff9a\001\002\000\004\043\163\001\002\000\016\004" +
    "\112\020\110\035\103\052\101\053\102\054\104\001\002" +
    "\000\016\017\133\036\162\045\127\046\130\047\132\050" +
    "\131\001\002\000\010\014\uff9f\025\uff9f\043\uff9f\001\002" +
    "\000\010\014\uff9e\025\uff9e\043\uff9e\001\002\000\020\003" +
    "\167\017\133\026\170\045\127\046\130\047\132\050\131" +
    "\001\002\000\004\043\166\001\002\000\010\014\uffae\025" +
    "\uffae\043\uffae\001\002\000\010\014\uffaf\025\uffaf\043\uffaf" +
    "\001\002\000\024\004\073\014\uffbf\016\057\024\063\025" +
    "\uffbf\030\075\032\052\033\070\034\055\001\002\000\006" +
    "\014\uffac\025\173\001\002\000\004\014\175\001\002\000" +
    "\022\004\073\014\uffbf\016\057\024\063\030\075\032\052" +
    "\033\070\034\055\001\002\000\004\014\uffad\001\002\000" +
    "\010\014\uffb0\025\uffb0\043\uffb0\001\002\000\024\004\073" +
    "\014\uffc1\016\057\024\063\025\uffc1\030\075\032\052\033" +
    "\070\034\055\001\002\000\010\014\uffbe\025\uffbe\043\uffbe" +
    "\001\002\000\004\043\203\001\002\000\016\004\112\020" +
    "\110\035\103\052\101\053\102\054\104\001\002\000\022" +
    "\014\uffb2\017\133\025\uffb2\043\uffb2\045\127\046\130\047" +
    "\132\050\131\001\002\000\010\014\uffb1\025\uffb1\043\uffb1" +
    "\001\002\000\022\014\uffb4\017\133\025\uffb4\043\uffb4\045" +
    "\127\046\130\047\132\050\131\001\002\000\004\043\206" +
    "\001\002\000\010\014\uffb3\025\uffb3\043\uffb3\001\002\000" +
    "\006\003\210\004\211\001\002\000\010\002\ufff9\013\ufff9" +
    "\015\ufff9\001\002\000\004\043\212\001\002\000\010\002" +
    "\ufffa\013\ufffa\015\ufffa\001\002\000\004\007\216\001\002" +
    "\000\004\043\215\001\002\000\010\014\uffa0\025\uffa0\043" +
    "\uffa0\001\002\000\004\036\217\001\002\000\010\014\uffa1" +
    "\025\uffa1\043\uffa1\001\002\000\006\013\uffdb\015\046\001" +
    "\002\000\004\013\uffdc\001\002\000\014\013\uffd8\015\uffd8" +
    "\021\uffd8\022\uffd8\023\uffd8\001\002\000\012\003\225\035" +
    "\224\043\uffd6\044\uffd6\001\002\000\006\004\240\036\uffd3" +
    "\001\002\000\014\013\uffd9\015\uffd9\021\uffd9\022\uffd9\023" +
    "\uffd9\001\002\000\006\043\uffcf\044\230\001\002\000\004" +
    "\043\234\001\002\000\010\003\231\005\037\006\041\001" +
    "\002\000\004\043\233\001\002\000\004\043\uffd0\001\002" +
    "\000\004\043\uffce\001\002\000\014\013\uffda\015\uffda\021" +
    "\uffda\022\uffda\023\uffda\001\002\000\006\003\246\044\247" +
    "\001\002\000\006\036\uffd4\043\244\001\002\000\004\036" +
    "\243\001\002\000\010\003\uffdf\042\241\044\uffdf\001\002" +
    "\000\004\004\240\001\002\000\006\003\uffe0\044\uffe0\001" +
    "\002\000\006\043\uffd7\044\uffd7\001\002\000\006\004\240" +
    "\036\uffd3\001\002\000\004\036\uffd5\001\002\000\004\043" +
    "\253\001\002\000\010\004\251\005\037\006\041\001\002" +
    "\000\006\036\uffd2\043\uffd2\001\002\000\006\036\uffdd\043" +
    "\uffdd\001\002\000\006\036\uffde\043\uffde\001\002\000\006" +
    "\036\uffd1\043\uffd1\001\002\000\006\003\261\044\262\001" +
    "\002\000\006\013\uffe5\015\uffe5\001\002\000\010\004\240" +
    "\013\uffe7\015\uffe7\001\002\000\010\004\uffe3\013\uffe3\015" +
    "\uffe3\001\002\000\010\004\uffe4\013\uffe4\015\uffe4\001\002" +
    "\000\004\043\265\001\002\000\010\004\251\005\037\006" +
    "\041\001\002\000\004\043\264\001\002\000\010\004\uffe2" +
    "\013\uffe2\015\uffe2\001\002\000\010\004\uffe1\013\uffe1\015" +
    "\uffe1\001\002\000\014\004\ufff3\013\ufff3\015\ufff3\022\ufff3" +
    "\023\ufff3\001\002\000\012\013\ufff5\015\ufff5\022\ufff5\023" +
    "\ufff5\001\002\000\006\003\273\045\274\001\002\000\014" +
    "\004\270\013\ufff7\015\ufff7\022\ufff7\023\ufff7\001\002\000" +
    "\014\004\ufff4\013\ufff4\015\ufff4\022\ufff4\023\ufff4\001\002" +
    "\000\004\043\301\001\002\000\010\052\275\053\102\054" +
    "\104\001\002\000\004\043\ufff0\001\002\000\004\043\uffef" +
    "\001\002\000\004\043\300\001\002\000\014\004\ufff2\013" +
    "\ufff2\015\ufff2\022\ufff2\023\ufff2\001\002\000\014\004\ufff1" +
    "\013\ufff1\015\ufff1\022\ufff1\023\ufff1\001\002\000\016\003" +
    "\ufffb\013\ufffb\015\ufffb\021\ufffb\022\ufffb\023\ufffb\001\002" +
    "\000\004\043\304\001\002\000\016\003\ufffc\013\ufffc\015" +
    "\ufffc\021\ufffc\022\ufffc\023\ufffc\001\002\000\004\002\001" +
    "\001\002" });

  /** Access to parse-action table. */
  public short[][] action_table() {return _action_table;}

  /** <code>reduce_goto</code> table. */
  protected static final short[][] _reduce_table = 
    unpackFromStrings(new String[] {
    "\000\303\000\006\002\003\056\004\001\001\000\002\001" +
    "\001\000\006\003\005\004\007\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\005\011\006\013\001\001\000" +
    "\006\012\270\013\265\001\001\000\002\001\001\000\002" +
    "\001\001\000\004\007\014\001\001\000\004\010\044\001" +
    "\001\000\006\015\021\016\020\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\016\022\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\004\054\030\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\054\033" +
    "\001\001\000\002\001\001\000\002\001\001\000\004\053" +
    "\037\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\017" +
    "\255\020\256\021\253\001\001\000\006\011\047\023\046" +
    "\001\001\000\002\001\001\000\006\005\217\006\013\001" +
    "\001\000\002\001\001\000\032\030\053\031\061\032\064" +
    "\036\060\037\055\042\063\043\073\044\065\046\066\047" +
    "\052\050\071\051\057\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\014\033\203\034\106\035\112\036\110\055\105" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\014\033\163\034\106\035\112\036\110\055\105" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\006\040\155\052\115\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\014\033\104\034\106\035\112\036\110\055" +
    "\105\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\033\152\034\106\035\112\036\110\055\105\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\014\033\142\034\106\035\112\036\110\055" +
    "\105\001\001\000\002\001\001\000\006\040\116\052\115" +
    "\001\001\000\002\001\001\000\014\033\140\034\106\035" +
    "\112\036\110\055\105\001\001\000\016\033\117\034\106" +
    "\035\112\036\110\041\121\055\105\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\014\033\125\034" +
    "\106\035\112\036\110\055\105\001\001\000\002\001\001" +
    "\000\002\001\001\000\014\033\137\034\106\035\112\036" +
    "\110\055\105\001\001\000\014\033\136\034\106\035\112" +
    "\036\110\055\105\001\001\000\014\033\135\034\106\035" +
    "\112\036\110\055\105\001\001\000\014\033\134\034\106" +
    "\035\112\036\110\055\105\001\001\000\014\033\133\034" +
    "\106\035\112\036\110\055\105\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\014\033\144\034\106\035\112\036\110\055" +
    "\105\001\001\000\002\001\001\000\032\030\150\031\061" +
    "\032\064\036\060\037\055\042\063\043\073\044\065\046" +
    "\066\047\052\050\071\051\057\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\014\033\160\034\106\035" +
    "\112\036\110\055\105\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\032\030\170" +
    "\031\061\032\064\036\060\037\055\042\063\043\073\044" +
    "\065\046\066\047\052\050\071\051\057\001\001\000\004" +
    "\045\171\001\001\000\002\001\001\000\032\030\173\031" +
    "\061\032\064\036\060\037\055\042\063\043\073\044\065" +
    "\046\066\047\052\050\071\051\057\001\001\000\002\001" +
    "\001\000\002\001\001\000\026\032\176\036\060\037\055" +
    "\042\063\043\073\044\065\046\066\047\052\050\071\051" +
    "\057\001\001\000\002\001\001\000\002\001\001\000\014" +
    "\033\201\034\106\035\112\036\110\055\105\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\006\011\220\023\046\001\001\000\002" +
    "\001\001\000\002\001\001\000\004\025\225\001\001\000" +
    "\010\021\234\026\236\027\235\001\001\000\002\001\001" +
    "\000\004\024\226\001\001\000\002\001\001\000\004\053" +
    "\231\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\004\021\241" +
    "\001\001\000\002\001\001\000\002\001\001\000\010\021" +
    "\234\026\244\027\235\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\022\247\053\251\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\006\020\257\021" +
    "\253\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\006\022\262\053\251\001\001\000\002\001" +
    "\001\000\002\001\001\000\002\001\001\000\002\001\001" +
    "\000\002\001\001\000\002\001\001\000\004\013\271\001" +
    "\001\000\002\001\001\000\002\001\001\000\006\014\276" +
    "\055\275\001\001\000\002\001\001\000\002\001\001\000" +
    "\002\001\001\000\002\001\001\000\002\001\001\000\002" +
    "\001\001\000\002\001\001\000\002\001\001\000\002\001" +
    "\001" });

  /** Access to <code>reduce_goto</code> table. */
  public short[][] reduce_table() {return _reduce_table;}

  /** Instance of action encapsulation class. */
  protected CUP$parser$actions action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new CUP$parser$actions(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java_cup.runtime.lr_parser parser,
    java.util.Stack            stack,
    int                        top)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$parser$do_action(act_num, parser, stack, top);
  }

  /** Indicates start state. */
  public int start_state() {return 0;}
  /** Indicates start production. */
  public int start_production() {return 0;}

  /** <code>EOF</code> Symbol index. */
  public int EOF_sym() {return 0;}

  /** <code>error</code> Symbol index. */
  public int error_sym() {return 1;}



	SyntaxErrorManager syntaxErrorManager = CompilerContext.getSyntaxErrorManager();
	
	public void syntax_error(Symbol symbol)
	{ 
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxError ("Error sintactico", token);	    
	}
		
	public void unrecovered_syntax_error(java_cup.runtime.Symbol symbol)
	{	
	    Token token = (Token) symbol.value;
	    syntaxErrorManager.syntaxFatalError ("Error fatal", token);
	}

}

/** Cup generated class to encapsulate user supplied action code.*/
class CUP$parser$actions {


	
	SyntaxErrorManager   syntaxErrorManager   = CompilerContext.getSyntaxErrorManager();
	SemanticErrorManager semanticErrorManager = CompilerContext.getSemanticErrorManager ();
	ScopeManagerIF       scopeManager         = CompilerContext.getScopeManager ();
	FinalCodeFactoryIF   finalCodeFactory     = CompilerContext.getFinalCodeFactory ();

	public TypeIF getExpresionTypeResult(Expresion expresion) {
					ScopeIF scope = scopeManager.getCurrentScope();
				SymbolTableIF symbolTable = scope.getSymbolTable();
						TypeTableIF typeTable = scope.getTypeTable();
	
		if (expresion.geteA() != null) {
			return typeTable.getType("int");
		} else if (expresion.geteL() != null) {
			return typeTable.getType("boolean");
		} else if (expresion.getV() != null) {
			if (expresion.getV().getpF()!= null && expresion.getV().getpF().getP() !=null && expresion.getV().getpF().getP().getListE().size() > 0) {
				return getExpresionTypeResult(expresion.getV().getpF().getP().getListE().get(0));
			} else if (expresion.getV().getIdA() != null) {
				return getExpresionTypeResult(expresion.getV().getIdA().getE());
			} else if (expresion.getV().getId() != null) {
				return symbolTable.getSymbol(expresion.getV().getId()).getType();
			}
		} else {
			return getExpresionTypeResult(expresion.getListE().get(0));
		}
		return getExpresionTypeResult(expresion.getListE().get(0));
	}
	
	int contador=0;

	List<QuadrupleIF> listaCadenas = new ArrayList<QuadrupleIF>();
//	List<QuadrupleIF> chains = new ArrayList<QuadrupleIF>();   //Lista que almacena cuÃ¡druplas de cadenas de caracteres.



  private final parser parser;

  /** Constructor */
  CUP$parser$actions(parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  public final java_cup.runtime.Symbol CUP$parser$do_action(
    int                        CUP$parser$act_num,
    java_cup.runtime.lr_parser CUP$parser$parser,
    java.util.Stack            CUP$parser$stack,
    int                        CUP$parser$top)
    throws java.lang.Exception
    {
      /* Symbol object for return from actions */
      java_cup.runtime.Symbol CUP$parser$result;

      /* select the action based on the action number */
      switch (CUP$parser$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 110: // vBooleano ::= FALSE 
            {
              VBooleano RESULT =null;
		
						//	Se crea vBooleano con el valor false
						VBooleano vBooleano = new VBooleano(false);
						semanticErrorManager.semanticInfo("vBooleano false: " + vBooleano.getValue());
						RESULT = vBooleano;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("vBooleano",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 109: // vBooleano ::= TRUE 
            {
              VBooleano RESULT =null;
		
						//	Se crea vBooleano con el valor true
						VBooleano vBooleano = new VBooleano(true);
						semanticErrorManager.semanticInfo("vBooleano true: " + vBooleano.getValue());
						RESULT = vBooleano;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("vBooleano",43, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 108: // entOid ::= IDENTIFICADOR 
            {
              EntOid RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea entOid con el identificador recibido y se le asigna el tipo
						EntOid entOid = new EntOid(id.getLexema().toLowerCase(), "STRING");
						RESULT = entOid;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("entOid",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 107: // entOid ::= ENTERO 
            {
              EntOid RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token e = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea entOid con el entero recibido y se le asigna el tipo
						EntOid entOid = new EntOid(Integer.parseInt(e.getLexema().toLowerCase()), "INTEGER");
						RESULT = entOid;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("entOid",42, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 106: // intOBool ::= BOOLEAN 
            {
              IntOBool RESULT =null;
		
						//	Se crea intOBool con el boolean recibido
						semanticErrorManager.semanticInfo("intOBool: BOOLEAN");
						IntOBool intOBool = new IntOBool("BOOLEAN");
						RESULT = intOBool;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("intOBool",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 105: // intOBool ::= INTEGER 
            {
              IntOBool RESULT =null;
		
						//	Se crea intOBool con el entero recibido
						semanticErrorManager.semanticInfo("intOBool: INTEGER");
						IntOBool intOBool = new IntOBool("INTEGER");
						RESULT = intOBool;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("intOBool",41, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 104: // idArray ::= CORCHIZQ expresion CORCHDER 
            {
              IdArray RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						//	Se crea idArray con la expresion recibida
						semanticErrorManager.semanticInfo("idArray: recupero expresion y lo creo");
						IdArray idArray = new IdArray(e);
						RESULT = idArray;						
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("idArray",40, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 103: // variables ::= IDENTIFICADOR parFuncion 
            {
              Variables RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int pFleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pFright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ParFuncion pF = (ParFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Comprobaciones semanticas
						ScopeIF scope = scopeManager.getCurrentScope();
						SymbolTableIF symbolTable = scope.getSymbolTable();
						//	Se comprueba que el id este en la tabla de simbolos
						if(!symbolTable.containsSymbol(id.getLexema().toLowerCase())){
							semanticErrorManager.semanticFatalError("Identificador " + id + " no existente 5");
						}
						semanticErrorManager.semanticInfo("variables: id + parFuncion");
						Variables variables = new Variables(id.getLexema().toLowerCase(), pF);

						//	Comprobamos que los parametros son correctos
						//	Obtenemos el simbolo en la tabla de simbolos
						SymbolProcedure symbol = (SymbolProcedure) symbolTable.getSymbol(id.getLexema().toLowerCase());
//	MAGIA		Parece hecho
						//	Se comprueba que las llamadas a funciones se realicen con el numero de parametros correcto
						int contParam = 0;
						for(ProcParam procParam : symbol.getcP().getpP().getpLP().getlistPP()){
							contParam+=procParam.getcIdV().getListId().size();
						}
						if(pF.getP() != null && pF.getP().getListE().size() != contParam){
							semanticErrorManager.semanticFatalError("Llamada a funcion con numero de parametros incorrecto");
						}

						//	Se comprueba que el simbolo asignado sea distinto de null
						if(symbol.getcP().getpP().getpLP().getlistPP() != null){
							for(ProcParam procParam : symbol.getcP().getpP().getpLP().getlistPP()){
//								semanticErrorManager.semanticInfo("--- ProcParam 1:" + procParam);
//							}
//							for(int i=0;i<symbol.getcP().getpP().getpLP().getlistPP().size();i++) {
								//Comprobamos en base a la definicion
//								ProcParam procParam = symbol.getcP().getpP().getpLP().getlistPP().get(i);
								CadIdVar cadIdVar = procParam.getcIdV();
								TipoVar tipoVar = procParam.gettV();
								if(cadIdVar!=null && cadIdVar.getListId()!=null){
									for(int j=0; j<cadIdVar.getListId().size(); j++){
										//	Comprobamos si son los mismos tipos
										//	Recupero el tipo de la primera funcion
										TypeIF tipoF1 = null;
	
										List<ScopeIF> scopes = scopeManager.getAllScopes();
										for(ScopeIF scopeFor : scopes){
											TypeTableIF typeTableFor = scopeFor.getTypeTable();
											tipoF1 = typeTableFor.getType(tipoVar.getIdentificadorTipo());
											if (tipoF1==null) {
												while(scopeFor.getParentScope() != null){
													scopeFor = scopeFor.getParentScope();
													typeTableFor = scopeFor.getTypeTable();
													tipoF1 = typeTableFor.getType(tipoVar.getIdentificadorTipo());
													if(tipoF1 == null){
														semanticErrorManager.semanticFatalError("Tipo no encontrado");
													}
												}
											}
										}
										//	Recupero el tipo de la segunda funcion
										TypeIF tipoF2;
										Expresion expF2 = pF.getP().getListE().get(j);
										tipoF2 = getExpresionTypeResult(expF2);
	
										//	Comparo los tipos de las funciones
										semanticErrorManager.semanticInfo("Los tipos son. Tipo 1: " + tipoF1 + " Tipo 2: " + tipoF2);
										if(tipoF1.getName().equals(tipoF2.getName())) {
											semanticErrorManager.semanticInfo("Tipos iguales. Tipo 1: " + tipoF1 + " Tipo 2: " + tipoF2);
										} else { 
											semanticErrorManager.semanticFatalError("Los tipos no corresponden al esperado. Tipo 1: " + tipoF1 + " Tipo 2: " + tipoF2);
										}
									}
								}
							}
						}

						//	Codigo intermedio
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalFactoryIF tf = new TemporalFactory(scope);
						LabelFactoryIF lf = new LabelFactory();
						TemporalIF temp = tf.create();
						LabelIF l1 = lf.create(id.getLexema().toLowerCase());
						SymbolIF symbolId = symbolTable.getSymbol(id.getLexema().toLowerCase());
						Procedure procedure = new Procedure(id.getLexema().toLowerCase(), scope, symbol);
						  
						//Codigo de los parametros
						cb.addQuadruples(pF.getIntermediateCode());
						cb.addQuadruple("CALL", procedure, temp);
						
						if(symbolId instanceof SymbolFunction) {
						cb.addQuadruple("RETVALUE",temp);
						}
						
						variables.setIntermediateCode(cb.create());
						variables.setTemporal(temp);

						RESULT = variables;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variables",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 102: // variables ::= IDENTIFICADOR idArray 
            {
              Variables RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int idAleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idAright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		IdArray idA = (IdArray)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea variables con el identificador y el idArray recibidos
						Variables variables = new Variables(id.getLexema().toLowerCase(), idA);
semanticErrorManager.semanticInfo("ID IDARRAY");
						//	Comprobaciones semanticas
						//	Se recupera el ambito y la tabla de simbolos
						ScopeIF scope = scopeManager.getCurrentScope();
						SymbolTableIF symbolTable = scope.getSymbolTable();

						//	Se comprueba que el identificador este en la tabla de simbolos
						if(!symbolTable.containsSymbol(id.getLexema().toLowerCase())){
							semanticErrorManager.semanticFatalError("Identificador " + id + " no existente 4");
						}

						//	Se comprueba si hay una expresion aritmetica
						if(idA.getE().geteA() != null) {
							//	Se recoge el tipo de la expresion si tiene un valor guardado
							if(idA.getE().geteA().getEntero() != null){
								SymbolVariable symbolVariable = (SymbolVariable) symbolTable.getSymbol(id.getLexema().toLowerCase());
								TypeIF type = symbolVariable.getType();
								//	Se comrpueba si es un array
								if (type instanceof TypeArray) {
									TypeArray typeArray = (TypeArray) type;
									int posArray = idA.getE().geteA().getEntero();
									int minimo = typeArray.getExpTipo().geteOid1().getValor();
									int maximo = typeArray.getExpTipo().geteOid2().getValor();
									//	Se comprueba si la posicion del array es correcta
									if (posArray < minimo || posArray > maximo){
										semanticErrorManager.semanticFatalError("Posicion de array seleccionada erronea");
									}
								}
							}
						semanticErrorManager.semanticInfo("Es arit" );							
						}

						//	Se comprueba si hay una expresion variable
						if (idA.getE().getV()!= null){
							//	Se recupera el simbolo de la variable
							String idVar = idA.getE().getV().getId();
							SymbolVariable symbolVariableIdArray = (SymbolVariable) symbolTable.getSymbol(idVar);
							if (!symbolVariableIdArray.getType().getName().equals("int") && !symbolVariableIdArray.getType().getName().equals("tvector")) {
								semanticErrorManager.semanticFatalError("Acceso a posicion de array con variable no entera");
							}
						semanticErrorManager.semanticInfo("Es var" );							

						}

						semanticErrorManager.semanticInfo("variables: id + idArray: " );

						//Codigo intermedio
						TemporalFactory tf = new TemporalFactory(scope);
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
						SymbolIF symbol = scopeManager.searchSymbol(id.getLexema().toLowerCase());
						
						TemporalIF temp = tf.create();
						TemporalIF temp1 = tf.create();
						TemporalIF temp2 = tf.create();
						TemporalIF temp3 = tf.create();
						
						if (symbol instanceof SymbolVariable) {
							Variable variable = new Variable(id.getLexema().toLowerCase(), symbol.getScope());
							SymbolProcedure enclosingSymbol = (SymbolProcedure) scopeManager.searchSymbol(scope.getName());
							variable.setEnclosingSymbol(enclosingSymbol);
							cb.addQuadruple("MVA", temp, variable);   
							variables.setVariable(variable);
						} else if (symbol instanceof SymbolParameter) { 
							OperandIF  o = new Variable(id.getLexema().toLowerCase(), symbol);     
							SymbolProcedure enclosingSymbol = (SymbolProcedure) scopeManager.searchSymbol(scope.getName());
							((Variable) o).setEnclosingSymbol(enclosingSymbol);
							((Variable) o).setParameter(true);
							variables.setVariable((Variable)o);
							cb.addQuadruple("MVA", temp, o);   
						} else {
							SymbolConstant constant = (SymbolConstant) symbol;
							OperandIF o = new Value(constant.getValue());
							cb.addQuadruple("MV", temp, o);
						}
						
						TemporalIF tempPosicion = idA.getE().getTemporal();
						cb.addQuadruple("MV", temp2, tempPosicion);
						cb.addQuadruple("ADD", temp3, temp1, temp2);
						cb.addQuadruple("MVP", temp, temp3);
						
						variables.setTemporal(temp); 
						variables.setIntermediateCode(cb.create());

						RESULT = variables;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variables",28, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 101: // variables ::= IDENTIFICADOR 
            {
              Variables RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea variables con el identificador recibido
						//	Comprobaciones semanticas
						//	Se recuperan el ambito y tabla de simbolos
						ScopeIF scope = scopeManager.getCurrentScope();
						SymbolTableIF symbolTable = scope.getSymbolTable();

						//	Se comprueba que el identificador este en la tabla de simbolos
						if(!symbolTable.containsSymbol(id.getLexema().toLowerCase())){
							semanticErrorManager.semanticInfo("Estoy en el scope: " + scope + " buscando: " + id.getLexema());
							semanticErrorManager.semanticFatalError("Identificador " + id + " no existente 3");
						} else {
							semanticErrorManager.semanticInfo("Id encontrado");
						}
						semanticErrorManager.semanticInfo("variables: id: " + id.getLexema().toLowerCase());
						Variables variables = new Variables(id.getLexema().toLowerCase());

				//Codigo intermedio
						TemporalFactory tf = new TemporalFactory(scope); 
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope); 
						TemporalIF temp = tf.create();
						SymbolIF symbol = scopeManager.searchSymbol(id.getLexema().toLowerCase());
						
						if (symbol instanceof SymbolVariable) {
							Variable variable = new Variable(id.getLexema().toLowerCase(), symbol.getScope());
							SymbolProcedure enclosingSymbol = (SymbolProcedure) scopeManager.searchSymbol(scope.getName());
							variable.setEnclosingSymbol(enclosingSymbol);
							cb.addQuadruple("MVP", temp, variable);   
							variables.setVariable(variable);
						} else if (symbol instanceof SymbolParameter) { 
							OperandIF  o = new Variable(id.getLexema().toLowerCase(), symbol);     
							SymbolProcedure enclosingSymbol = (SymbolProcedure) scopeManager.searchSymbol(scope.getName());
							((Variable) o).setEnclosingSymbol(enclosingSymbol);
							((Variable) o).setParameter(true);      
							variables.setVariable((Variable)o);
							cb.addQuadruple("MVA", temp, o);   
						} else {
							SymbolConstant constant = (SymbolConstant) symbol;
							OperandIF o = new Value(constant.getValue());
							cb.addQuadruple("MV", temp, o); 
						}

						variables.setTemporal(temp);
						variables.setIntermediateCode(cb.create());

						RESULT = variables;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("variables",28, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 100: // sWriteLn ::= WRITELN 
            {
              SWriteLn RESULT =null;
		
						//	Se crea sWriteLn
						semanticErrorManager.semanticInfo("sWriteLn: sWriteLn");
						SWriteLn sWriteLn = new SWriteLn();
/*
						//Generacion de Codigo Intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactory tF = new TemporalFactory(scope);
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
						LabelFactory lF = new LabelFactory();
						LabelIF lb = lF.create();
						TemporalIF temp = tF.create();
						cb.addQuadruple("WRITELN", temp, lb);
						sWriteLn.setIntermediateCode(cb.create());
*/
						ScopeIF scope = scopeManager.getCurrentScope();
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruple("WRITELN");
						sWriteLn.setIntermediateCode(cb.create());

						RESULT = sWriteLn;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sWriteLn",39, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 99: // sWriteInt ::= WRITEINT error PUNTOYCOMA 
            {
              SWriteInt RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error sWriteInt");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sWriteInt",38, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 98: // sWriteInt ::= WRITEINT PARENIZQ expresion PARENDER 
            {
              SWriteInt RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						//	Se crea sWriteInt con el int recibido
						SWriteInt sWriteInt = new SWriteInt(e);
						semanticErrorManager.semanticInfo("sWriteInt: Escribo: " + sWriteInt.getE() );

						//Generacion de Codigo Intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF temp = e.getTemporal();
						cb.addQuadruples(e.getIntermediateCode());
						cb.addQuadruple("WRITEINT", temp);
						sWriteInt.setIntermediateCode(cb.create());

						RESULT = sWriteInt;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sWriteInt",38, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 97: // sWriteString ::= WRITESTRING error PUNTOYCOMA 
            {
              SWriteString RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error sWriteString");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sWriteString",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 96: // sWriteString ::= WRITESTRING PARENIZQ STRING PARENDER 
            {
              SWriteString RESULT =null;
		int stringleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int stringright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token string = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
                SWriteString sWriteString = new SWriteString(string.getLexema().toLowerCase());
                
ScopeIF scope = scopeManager.getCurrentScope();
                
TemporalFactory tF = new TemporalFactory(scope);
IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
String texto = string.getLexema();
LabelFactory lF = new LabelFactory();
LabelIF lb = lF.create();
TemporalIF temp = tF.create();
cb.addQuadruple("WRITESTRING", lb);
//Guardamos la cadena de caracteres en "listaCadena" y la recuperaremos al final del programa principal
listaCadenas.add(new Quadruple("CADENA", new compiler.intermediate.Label(texto), lb));
sWriteString.setIntermediateCode(cb.create());
//printamos el código intermedio generado
System.out.println("Codigo intermedio: " + sWriteString.getIntermediateCode());
                
                
                
                
                
/*
ScopeIF scope = scopeManager.getCurrentScope();
//Generacion de Codigo Intermedio
TemporalFactory tF = new TemporalFactory(scope);
IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
String texto = string.getLexema();
LabelFactory lF = new LabelFactory();
LabelIF lb = lF.create();
TemporalIF temp = tF.create();
cb.addQuadruple("WRITESTRING", temp, lb);
//Guardamos la cadena de caracteres en "listaCadena" y la recuperaremos al final del programa principal
	semanticErrorManager.semanticInfo("SWRITESTRING: " + texto + " - bla - " + lb );
chains.add(new Quadruple("CADENA", new Label(texto), lb));
cb.setIntermediateCode(cb.create());
//printamos el código intermedio generado
System.out.println("Codigo intermedio: " + cb.getIntermediateCode());
RESULT = cb;

/*
                //Generacion de Codigo Intermedio
				ScopeIF scope = scopeManager.getCurrentScope();
                TemporalFactory tF = new TemporalFactory(scope);
                IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
                LabelFactory lF = new LabelFactory();
                LabelIF lb = lF.create();
                TemporalIF temp = tF.create();
                cb.addQuadruple("WRITESTRING", null, new Value(string.getLexema()));
                sWriteString.setIntermediateCode(cb.create());

/*
						//Generacion de Codigo Intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(string.getLexema());
						cb.addQuadruple("WRITESTRING", string.getLexema());
						sWriteString.setIntermediateCode(cb.create());

*/
/*

		// GeneraciÃ³n de cÃ³digo intermedio
		// Recuperamos el Ã¡mbito actual
		ScopeIF scope = scopeManager.getCurrentScope();
		// Creamos una fÃ¡brica de etiquetas
		LabelFactoryIF lf = new LabelFactory();
		// Creamos el constructor de cÃ³digo intermedio
		IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
		// Creamos una nueva etiqueta
		LabelIF label = lf.create();
		// Almacenamos la cadena
		String chain = string.getLexema();
		// AÃ±adimos la instrucciÃ³n de entrada
		cb.addQuadruple("WRITESTRING",label);
		// AÃ±adimos la cuÃ¡drupla a la lista de cuÃ¡druplas de cadenas del programa
		chains.add(new Quadruple("CADENA", new compiler.intermediate.Label(chain), label));
		// Generamos el cÃ³digo intermedio
		sWriteString.setIntermediateCode(cb.create());
*/

				RESULT = sWriteString;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sWriteString",37, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 95: // parametros ::= expresion 
            {
              Parametros RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Si solo se recibe una expresion se crea parametros con la expresion recibida
						Parametros parametros = new Parametros(e);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF temp = e.getTemporal();
						cb.addQuadruples(e.getIntermediateCode());
						cb.addQuadruple("PARAM", temp);
						parametros.setIntermediateCode(cb.create());

						RESULT = parametros;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",31, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 94: // parametros ::= parametros COMA expresion 
            {
              Parametros RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Parametros p = (Parametros)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se añade la expresion a la lista de parametros
						p.addE(e);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF temp = e.getTemporal();
						cb.addQuadruples(e.getIntermediateCode());
						cb.addQuadruples(p.getIntermediateCode());
						cb.addQuadruple("PARAM", temp);
						p.setIntermediateCode(cb.create());

						RESULT = p;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parametros",31, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 93: // parFuncion ::= PARENIZQ error 
            {
              ParFuncion RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error parFuncion");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parFuncion",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 92: // parFuncion ::= PARENIZQ PARENDER 
            {
              ParFuncion RESULT =null;
		
						//	Se crea par funcion sin parametros
						ParFuncion parFuncion = new ParFuncion();
						RESULT = parFuncion;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parFuncion",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 91: // parFuncion ::= PARENIZQ parametros PARENDER 
            {
              ParFuncion RESULT =null;
		int pleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int pright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Parametros p = (Parametros)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						//	Se crea parFuncion guardando parametros
						ParFuncion parFuncion = new ParFuncion(p);

						//	Codigo intermedio  
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruple("STARTRA");
						cb.addQuadruples(p.getIntermediateCode());
						parFuncion.setIntermediateCode(cb.create());

						RESULT = parFuncion;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("parFuncion",30, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 90: // sentProcedure ::= IDENTIFICADOR parFuncion 
            {
              SentProcedure RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int pFleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pFright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ParFuncion pF = (ParFuncion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentProcedure con el identificador y parFuncion recibidos
						//	Comprobaciones semanticas
						//	Se recupera ambito y tabla de simbolos y tipos
						ScopeIF scope = scopeManager.getCurrentScope();
						SymbolTableIF symbolTable = scope.getSymbolTable();
						TypeTableIF typeTable = scope.getTypeTable();

						//	Se comprueba que el identificador haya sido declarado anteriormente
						if(!symbolTable.containsSymbol(id.getLexema().toLowerCase())){
							semanticErrorManager.semanticFatalError("Identificador " + id.getLexema() + " no existente 2");
						}

						SentProcedure sentProcedure = new SentProcedure(id.getLexema().toLowerCase(), pF);

						//	Se recupera el simbolo del identificador almacenado en la tabla
						SymbolProcedure symbol = (SymbolProcedure) symbolTable.getSymbol(id.getLexema().toLowerCase());

						int definedParams = 0;
						for(ProcParam procParam : symbol.getcP().getpP().getpLP().getlistPP()){
							definedParams+=procParam.getcIdV().getListId().size();
						}

						if(pF.getP()!=null && pF.getP().getListE().size()!=definedParams){
							semanticErrorManager.semanticFatalError("Numero de parametros de llamada a funcion incorrecto");
						}

						if(symbol.getcP().getpP().getpLP().getlistPP()!=null) {
							for(int i=0;i<symbol.getcP().getpP().getpLP().getlistPP().size();i++) {
							//Comprobamos en base a la definicion
								ProcParam procParam = symbol.getcP().getpP().getpLP().getlistPP().get(i);
								CadIdVar cadIdVar = procParam.getcIdV();
								TipoVar tipoVar   = procParam.gettV();

								for(int j=0;j<cadIdVar.getListId().size();j++){
								//	Comprobamos si son los mismos tipos
								//	Recupero el tipo de la primera funcion
									TypeIF tipoF1 = null;

									List<ScopeIF> scopes = scopeManager.getAllScopes();
									for(ScopeIF scopeFor : scopes){
										TypeTableIF typeTableFor = scopeFor.getTypeTable();
										tipoF1 = typeTableFor.getType(tipoVar.getIdentificadorTipo());
										if (tipoF1==null) {
											while(scopeFor.getParentScope() != null){
												scopeFor = scopeFor.getParentScope();
												typeTableFor = scopeFor.getTypeTable();
												tipoF1 = typeTableFor.getType(tipoVar.getIdentificadorTipo());
												if(tipoF1 == null){
													semanticErrorManager.semanticFatalError("Tipo no encontrado");
												}
											}
										}
									}
									//	Recupero el tipo de la segunda funcion
									TypeIF tipoF2;
									Expresion expF2 = pF.getP().getListE().get(j);
									tipoF2 = getExpresionTypeResult(expF2);

									//	Comparo los tipos de las funciones
									semanticErrorManager.semanticInfo("Los tipos son. Tipo 1: " + tipoF1 + " Tipo 2: " + tipoF2);
									if(tipoF1.getName().equals(tipoF2.getName())) {
										semanticErrorManager.semanticInfo("Tipos iguales. Tipo 1: " + tipoF1 + " Tipo 2: " + tipoF2);
									} else { 
										semanticErrorManager.semanticFatalError("Los tipos no corresponden al esperado. Tipo 1: " + tipoF1 + " Tipo 2: " + tipoF2);
									}
								}
							}
						}
//	MAGIA ver, igual falla
						// GeneraciÃ³n de cÃ³digo intermedio
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalFactoryIF tf = new TemporalFactory(scope);
						LabelFactoryIF lf = new LabelFactory();
						TemporalIF temp = tf.create();
						LabelIF l1 = lf.create(id.getLexema().toLowerCase());
						sentProcedure.setTemporal(temp);
						
						Procedure procedure = new Procedure(id.getLexema().toLowerCase(), scope, symbol);
						
						//	Codigo de los parametros
						cb.addQuadruples(pF.getIntermediateCode());
						
						cb.addQuadruple("CALL", procedure, temp);
						cb.addQuadruple("RETURNVALUE",temp);
						
						sentProcedure.setIntermediateCode(cb.create());
						sentProcedure.setTemporal(temp);

						RESULT = sentProcedure;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentProcedure",29, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 89: // sentProcedure ::= IDENTIFICADOR 
            {
              SentProcedure RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentProcedure con el identificador recibido
						//	Comprobaciones semanticas
						//	Se recupera ambito y tabla de simbolos
						ScopeIF scope = scopeManager.getCurrentScope();
						SymbolTableIF symbolTable = scope.getSymbolTable();
						SymbolProcedure symbol = (SymbolProcedure) symbolTable.getSymbol(id.getLexema().toLowerCase());

						//	Se comprueba que el identificador haya sido declarado anteriormente
						if(!symbolTable.containsSymbol(id.getLexema().toLowerCase())){
							semanticErrorManager.semanticFatalError("Identificador " + id.getLexema() + " no existente 1");
						}
						SentProcedure sentProcedure = new SentProcedure(id.getLexema().toLowerCase());
//	MAGIA	ver, igual falla
						//	Codigo intermedio
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalFactoryIF tf = new TemporalFactory(scope);
						LabelFactoryIF lf = new LabelFactory();
						TemporalIF temp = tf.create();
						LabelIF l1 = lf.create(id.getLexema().toLowerCase());
						
						Procedure procedure = new Procedure(id.getLexema().toLowerCase(), scope, symbol);
						cb.addQuadruple("CALL", procedure, temp);
						if (symbol instanceof SymbolFunction) {
							cb.addQuadruple("RETVALUE",temp);
						}
						sentProcedure.setIntermediateCode(cb.create());
						sentProcedure.setTemporal(temp);

						RESULT = sentProcedure;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentProcedure",29, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 88: // sentFor ::= FOR error PUNTOYCOMA 
            {
              SentFor RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error sentFor");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentFor",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // sentFor ::= FOR IDENTIFICADOR DOSPUNTOSIGUAL expresion TO expresion error PUNTOYCOMA 
            {
              SentFor RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error sentFor");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentFor",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // sentFor ::= FOR IDENTIFICADOR DOSPUNTOSIGUAL expresion TO expresion DO sentencias END 
            {
              SentFor RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Sentencias s = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
									contador += 1;
					
						ScopeIF scope = scopeManager.getCurrentScope();
						SymbolTableIF symbolTable = scope.getSymbolTable();
						SymbolIF symbol = symbolTable.getSymbol(id.getLexema().toLowerCase());
						ScopeIF scopeSymbol = symbol.getScope();
						//	Se crea sentFor con el identificador, expresiones y sentencias recibidas
						SentFor sentFor = new SentFor(id.getLexema().toLowerCase(), e1, e2, s);

                  IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
                  LabelFactoryIF lf = new LabelFactory();
                  TemporalFactoryIF tf = new TemporalFactory(scope);

LabelIF lab_for1 = lf.create();
LabelIF lab_for2 = lf.create();

/*                  LabelIF l1IF = lf.create();
                  
semanticErrorManager.semanticInfo("GETNAME DE L1IF: " + l1IF.getName());
//                  l1.setName(l1.getName() + String.valueOf(contador));

                  compiler.intermediate.Label lab_for1 = (compiler.intermediate.Label) l1IF;
semanticErrorManager.semanticInfo("GETNAME DE L1: " + lab_for1.getName());
                  lab_for1.setName(lab_for1.getName() + "_" + String.valueOf(contador));
semanticErrorManager.semanticInfo("GETNAME DE L1 CAMBIADO: " + lab_for1.getName());


                  LabelIF l2IF = lf.create();
semanticErrorManager.semanticInfo("GETNAME DE L2IF: " + l2IF.getName());
                  compiler.intermediate.Label lab_for2 = (compiler.intermediate.Label) l2IF;
semanticErrorManager.semanticInfo("GETNAME DE L2: " + lab_for2.getName());
                  lab_for2.setName(lab_for2.getName() + "_" + String.valueOf(contador));
//                  l2.setName() = l2.getName() + String.valueOf(contador);
semanticErrorManager.semanticInfo("GETNAME DE L2 CAMBIADO: " + lab_for2.getName());
                  
                  
semanticErrorManager.semanticInfo("Contador antes: " + contador);
*/                  
						Variable var = new Variable(id.getLexema().toLowerCase(), scopeSymbol);


			TemporalIF temp = tf.create();

			TemporalIF eTemp1 = e1.getTemporal();
			TemporalIF eTemp2 = e2.getTemporal();

    cb.addQuadruples (e2.getIntermediateCode());
	cb.addQuadruple ("INC", eTemp2);


//	cb.addQuadruple ("Empieza L1", lab_for1, contador);
//	cb.addQuadruple ("Empieza L2", lab_for2, contador);
	
	cb.addQuadruples (e1.getIntermediateCode());
	cb.addQuadruple ("INL", lab_for1);
	if(symbol instanceof SymbolVariable){
		cb.addQuadruple("MVA", temp, var);
		cb.addQuadruple("STP", temp, eTemp1);
    }
//    cb.addQuadruples (e2.getIntermediateCode());
    cb.addQuadruple ("CMP", eTemp1, eTemp2);
    cb.addQuadruple ("BZ", lab_for2);
	cb.addQuadruples(s.getIntermediateCode());
	cb.addQuadruple ("INC", eTemp1);
    e1.setTemporal(eTemp1);

    cb.addQuadruple ("BR", lab_for1);
    cb.addQuadruple ("INL", lab_for2);

//	cb.addQuadruples(s.getIntermediateCode());

//	cb.addQuadruple ("Fin L1", lab_for1, contador);
//	cb.addQuadruple ("Fin L2", lab_for2, contador);


	sentFor.setIntermediateCode(cb.create());

						RESULT = sentFor;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentFor",36, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // sentElse ::= 
            {
              SentElse RESULT =null;
		
						//	Si no se reciben sentencias se crea sentElse vacio
						SentElse sentElse = new SentElse();
						RESULT = sentElse;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentElse",35, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // sentElse ::= ELSE sentencias 
            {
              SentElse RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencias s = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentElse con las sentencias recibidas
						SentElse sentElse = new SentElse(s);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(s.getIntermediateCode());
						sentElse.setIntermediateCode(cb.create());

						RESULT = sentElse;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentElse",35, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // sentIf ::= IF error PUNTOYCOMA 
            {
              SentIf RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error sentIf");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentIf",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // sentIf ::= IF expresion error 
            {
              SentIf RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error sentIf");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentIf",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // sentIf ::= IF expresion THEN sentencias sentElse END 
            {
              SentIf RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Sentencias s = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sEleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sEright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		SentElse sE = (SentElse)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						//	Se crea sentIf con la expresion y sentencias recibidas
						SentIf sentIf = new SentIf(e, s, sE);
/*
						//Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						LabelFactory lF = new LabelFactory();
						IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
						LabelIF l1 = lF.create();
						LabelIF l2 = lF.create();
						cb.addQuadruples(e.getIntermediateCode());
						cb.addQuadruple("BRF", l1, e.getTemporal());
						cb.addQuadruples(s.getIntermediateCode());
						if (sE.getE() != null){
							cb.addQuadruple("BR", l2);
						}
						cb.addQuadruple("INL", l1);
						if(sE.getE() != null){
							cb.addQuadruples(sE.getIntermediateCode());
							cb.addQuadruple("INL", l2);
						}
						sentIf.setIntermediateCode(cb.create());
*/	//	MAGIA Esto igual falla
						ScopeIF scope = scopeManager.getCurrentScope();
						//Comprobaciones semánticas
						//Código intermedio
						LabelFactory lF = new LabelFactory();
						LabelIF etiquetaFin = lF.create(); //Etiqueta para fin de las sentenicas IF
						LabelIF etiquetaElse = lF.create(); //Etiqueta de comienzo parte Else
						TemporalIF expTemp = e.getTemporal();
						IntermediateCodeBuilder cb= new IntermediateCodeBuilder(scope);
						cb.addQuadruples(e.getIntermediateCode()); //añadir el código de la expresión
						cb.addQuadruple("BRF", expTemp, etiquetaElse); //si no se cumple la condicion salto etiquetaElse
						cb.addQuadruples (s.getIntermediateCode()); // añadir código sentencias parte IF
						cb.addQuadruple("BR", etiquetaFin); //salto a la etiquetaFin
						cb.addQuadruple("INL", etiquetaElse); // insertar etiquetaElse
						cb.addQuadruples(sE.getIntermediateCode()); //añadir código sentencias parte Else
						cb.addQuadruple("INL", etiquetaFin); // insertar etiquetaFin
						sentIf.setIntermediateCode(cb.create());
						//printamos el código intermedio generado
						System.out.println("Codigo intermedio: " + sentIf.getIntermediateCode());

						RESULT = sentIf;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentIf",34, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // sentAsign ::= variables error PUNTOYCOMA 
            {
              SentAsign RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error sentAsign");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentAsign",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // sentAsign ::= variables DOSPUNTOSIGUAL expresion 
            {
              SentAsign RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int vright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Variables v = (Variables)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentAsign con las variables y expresion recibida
						SentAsign sentAsign = new SentAsign(v, e);

						//	Comprobaciones semanticas
						//	Se recupera el ambito y tabla de simbolos
						ScopeIF scope = scopeManager.getCurrentScope();
						SymbolTableIF symbolTable = scope.getSymbolTable();

						//	Se recupera el simbolo de la variable recibida
						SymbolIF symbol = symbolTable.getSymbol(v.getId());

						//	Se comprueba que el simbolo no sea una constante
						if (symbol instanceof SymbolConstant) {
							semanticErrorManager.semanticFatalError(v.getId() +" es una constante, no se puede reasignar el valor");
						}

						semanticErrorManager.semanticInfo("La variable " + v.getId() + " vale: " + e.getValue());

/*						//	Codigo intermedio
						TemporalFactoryIF tf = new TemporalFactory(scope);		
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF tempE = e.getTemporal();
						TemporalIF temp = tf.create();
						cb.addQuadruples(e.getIntermediateCode());
						if (symbol instanceof TypeFunction) {
							cb.addQuadruple("MV", temp, tempE);
							cb.addQuadruple("MV", v.getVariable(), temp);
						} else {
//							cb.addQuadruples(v.getIntermediateCode());   	
//							cb.addQuadruple("MV", temp, tempE);
//	MAGIA igual hay que cambiar estas quad							cb.addQuadruple("MV", v.getVariable(), temp);
							cb.addQuadruple("MVA", temp, v.getVariable());
							cb.addQuadruple("STP", temp, tempE);
						}
				//		e.setTemporal(eTemp);
						sentAsign.setIntermediateCode(cb.create());

						RESULT = sentAsign;
*/
						
		// GeneraciÃ³n de cÃ³digo intermedio
		// Recuperamos el Ã¡mbito actual
//		ScopeIF scope = scopeManager.getCurrentScope();
		// Creamos una fabrica de temporales
		TemporalFactoryIF tf = new TemporalFactory(scope);
		// Creamos el constructor de cÃ³digo intermedio
		IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
		// Guardamos el temporal de la expresiÃ³n
		TemporalIF eTemp = e.getTemporal();
		// Creamos un nuevo temporal
		TemporalIF temp = tf.create();
		// AÃ±adimos el cÃ³digo intermedio de la expresiÃ³n
		cb.addQuadruples(e.getIntermediateCode());
		// Creamos una variable a partir del sÃ­mbolo de la variable
		Variable var = new Variable(symbol);
		// Generamos el cÃ³digo intermedio y le establecemos el temporal de la expresiÃ³n la asignaciÃ³n
		cb.addQuadruple("MVA",temp,var);
		cb.addQuadruple("STP",temp,eTemp);
		sentAsign.setTemporal(eTemp);
		sentAsign.setIntermediateCode(cb.create());

		RESULT = sentAsign;

/*

                  if (symbol instanceof TypeFunction) {
                      cb.addQuadruples(e.getIntermediateCode());
                      cb.addQuadruple("MV", temp, tempE);
                      cb.addQuadruple("MV", v.getVariable(), temp);
                  } else {
                      cb.addQuadruples(e.getIntermediateCode());
                      cb.addQuadruples(v.getIntermediateCode());   	
                      cb.addQuadruple("MV", temp, tempE);
                      cb.addQuadruple("MV", v.getVariable(), temp);
                  }
                   sentAsign.setIntermediateCode(cb.create());
                  RESULT = sentAsign;
*/

					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentAsign",32, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // sentReturn ::= RETURN error PUNTOYCOMA 
            {
              SentReturn RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error sentReturn");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentReturn",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // sentReturn ::= RETURN expresion 
            {
              SentReturn RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentReturn con la expresion recibida
						SentReturn sentReturn = new SentReturn(e);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalFactoryIF tf = new TemporalFactory(scope);
						LabelFactoryIF lf = new LabelFactory();
						TemporalIF temp = tf.create();
//	MAGIA	ver esa F	->	La tienen marcos y rober
						LabelIF l1 = lf.create("F" + scope.getName());
						cb.addQuadruples(e.getIntermediateCode());
						cb.addQuadruple("RET",l1, temp);
						sentReturn.setIntermediateCode(cb.create());

						RESULT = sentReturn;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentReturn",33, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // sentencia ::= sentProcedure 
            {
              Sentencia RESULT =null;
		int sPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sPright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentProcedure sP = (SentProcedure)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentencia con una sentencia de procedure
						Sentencia sentencia = new Sentencia(sP);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(sP.getIntermediateCode());
						sentencia.setIntermediateCode(cb.create());

						RESULT = sentencia;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // sentencia ::= sWriteLn 
            {
              Sentencia RESULT =null;
		int sWLleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sWLright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SWriteLn sWL = (SWriteLn)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentencia con una sentencia de escritura
						Sentencia sentencia = new Sentencia(sWL);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(sWL.getIntermediateCode());
						sentencia.setIntermediateCode(cb.create());

						RESULT = sentencia;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // sentencia ::= sWriteInt 
            {
              Sentencia RESULT =null;
		int sWIleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sWIright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SWriteInt sWI = (SWriteInt)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentencia con una sentencia de escritura Int
						Sentencia sentencia = new Sentencia(sWI);
						semanticErrorManager.semanticInfo("Sentencia: Recupero sWriteInt: " + sWI.getE() + "y hago la sentencia: " + sentencia.getsWI());

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(sWI.getIntermediateCode());
						sentencia.setIntermediateCode(cb.create());

						RESULT = sentencia;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // sentencia ::= sWriteString 
            {
              Sentencia RESULT =null;
		int sWSleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sWSright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SWriteString sWS = (SWriteString)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentencia con una sentencia de escritura String
						Sentencia sentencia = new Sentencia(sWS);
						semanticErrorManager.semanticInfo("Sentencia: Recupero sWriteString: " + sWS.getS() + "y hago la sentencia: " + sentencia.getsWS());

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(sWS.getIntermediateCode());
						sentencia.setIntermediateCode(cb.create());

						RESULT = sentencia;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // sentencia ::= sentReturn 
            {
              Sentencia RESULT =null;
		int sRleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sRright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentReturn sR = (SentReturn)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentencia con una sentencia return
						Sentencia sentencia = new Sentencia(sR);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(sR.getIntermediateCode());
						sentencia.setIntermediateCode(cb.create());

						RESULT = sentencia;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // sentencia ::= sentFor 
            {
              Sentencia RESULT =null;
		int sFleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sFright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentFor sF = (SentFor)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentencia con una sentencia for
						Sentencia sentencia = new Sentencia(sF);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(sF.getIntermediateCode());
						sentencia.setIntermediateCode(cb.create());

						RESULT = sentencia;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // sentencia ::= sentIf 
            {
              Sentencia RESULT =null;
		int sIleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sIright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentIf sI = (SentIf)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentencia con una sentencia de condicional
						Sentencia sentencia = new Sentencia(sI);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(sI.getIntermediateCode());
						sentencia.setIntermediateCode(cb.create());

						RESULT = sentencia;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // sentencia ::= sentAsign 
            {
              Sentencia RESULT =null;
		int sAleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sAright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentAsign sA = (SentAsign)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentencia con una sentencia de asignacion
						Sentencia sentencia = new Sentencia(sA);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(sA.getIntermediateCode());
						sentencia.setIntermediateCode(cb.create());

						RESULT = sentencia;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencia",24, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // listSentencia ::= sentencia 
            {
              ListSentencia RESULT =null;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia s = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Si solo hay una sentencia se crea listSentencia con ella
						ListSentencia listSentencia = new ListSentencia(s);
/*						semanticErrorManager.semanticInfo("listaSentencia: recupero la sentencia: " + s.getsA().getV() + s.getsA().getE() + " y hago una lista con ella");
//						semanticErrorManager.semanticInfo("listaSentencia: recupero la sentencia: " + s.getsI().getE() + s.getsI().getS() + s.getsI().getsE() + " y hago una lista con ella");
						semanticErrorManager.semanticInfo("listaSentencia: recupero la sentencia: " + s.getsF() + " y hago una lista con ella");
//						semanticErrorManager.semanticInfo("listaSentencia: recupero la sentencia: " + s.getsR().getE() + " y hago una lista con ella");
//						semanticErrorManager.semanticInfo("listaSentencia: recupero la sentencia: " + s.getsWS().getS() + " y hago una lista con ella");
//						semanticErrorManager.semanticInfo("listaSentencia: recupero la sentencia: " + s.getsWI().getE() + " y hago una lista con ella");
//						semanticErrorManager.semanticInfo("listaSentencia: recupero la sentencia: " + s.getsWL() + " y hago una lista con ella");
						semanticErrorManager.semanticInfo("listaSentencia: recupero la sentencia: " + s.getsP().getId() + s.getsP().getPf() + " y hago una lista con ella");
*/
						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(s.getIntermediateCode());
						listSentencia.setIntermediateCode(cb.create());


/*semanticErrorManager.semanticInfo("Imprimo CI sentencia:");
List intermediateS = s.getIntermediateCode ();
System.out.println("WOOOOO");
System.out.println("WOOOOO");
System.out.println(intermediateS);
*/

						RESULT = listSentencia;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("listSentencia",23, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // listSentencia ::= listSentencia PUNTOYCOMA sentencia 
            {
              ListSentencia RESULT =null;
		int lSleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int lSright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ListSentencia lS = (ListSentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Sentencia s = (Sentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se añade la sentencia a listSentencia
						lS.addS(s);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(lS.getIntermediateCode());
						lS.setIntermediateCode(cb.create());
/*
//semanticErrorManager.semanticInfo("Imprimo CI sentencia:");
//List intermediateS = s.getIntermediateCode ();
//System.out.println("WIIII");
//System.out.println("WIIII");
//System.out.println(intermediateS);
*/

						RESULT = lS;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("listSentencia",23, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // sentencias ::= 
            {
              Sentencias RESULT =null;
		
						//	Se crea sentencias vacio
						semanticErrorManager.semanticInfo("Sentencias: no hay sentencias");
						Sentencias sentencias = new Sentencias();
//System.out.println("WAAAA3");
//System.out.println("WAAAA3");
						RESULT = sentencias;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // sentencias ::= listSentencia 
            {
              Sentencias RESULT =null;
		int lSleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int lSright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ListSentencia lS = (ListSentencia)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea sentencias con listSentencia
						semanticErrorManager.semanticInfo("Sentencias: recupero la lista de sentencias");
						Sentencias sentencias = new Sentencias(lS);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(lS.getIntermediateCode());
						sentencias.setIntermediateCode(cb.create());

/*semanticErrorManager.semanticInfo("Imprimo CI sentencia:");
List intermediateLS = lS.getIntermediateCode ();
System.out.println("WAAAA2");
System.out.println("WAAAA2");
System.out.println(intermediateLS);
*/

						RESULT = sentencias;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",22, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // sentencias ::= listSentencia PUNTOYCOMA 
            {
              Sentencias RESULT =null;
		int lSleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int lSright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ListSentencia lS = (ListSentencia)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						//	Se crea sentencias con listSentencia
						semanticErrorManager.semanticInfo("Sentencias: recupero la lista de sentencias");
						Sentencias sentencias = new Sentencias(lS);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						cb.addQuadruples(lS.getIntermediateCode());
						sentencias.setIntermediateCode(cb.create());
/*
semanticErrorManager.semanticInfo("Imprimo CI sentencia:");
List intermediateLS = lS.getIntermediateCode ();
System.out.println("WAAAA1");
System.out.println("WAAAA1");
System.out.println(intermediateLS);
*/

						RESULT = sentencias;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentencias",22, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // exprLogica ::= vBooleano 
            {
              ExprLogica RESULT =null;
		int vBleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int vBright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		VBooleano vB = (VBooleano)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea la expresion logica con un booleano
						ExprLogica exprLogica = new ExprLogica(vB.getValue());
						semanticErrorManager.semanticInfo("exprLogica: Recupero vBooleano " + vB.getValue() + "y creo exprLogica: " + exprLogica.getVB());

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF temp = tf.create();
//	MAGIA Ver Boolean.compare
						cb.addQuadruple("MV", temp, Boolean.compare(vB.getValue(), false));
						exprLogica.setTemporal(temp);
						exprLogica.setIntermediateCode(cb.create());

						RESULT = exprLogica;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprLogica",27, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // exprLogica ::= NOT expresion 
            {
              ExprLogica RESULT =null;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token o = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea la expresion logica con el simbolo not
						ExprLogica exprLogica = new ExprLogica(o.getLexema().toLowerCase(), e1);

ScopeIF scope1 = scopeManager.getCurrentScope();
SymbolTableIF symbolTable = scope1.getSymbolTable();
//SymbolVariable symbolVariable1 = (SymbolVariable) symbolTable.getSymbol(e1.getV().getId());
//TypeIF tipo = symbolVariable1.getType();


if (e1.getTipo() == "Aritmetica"){
	semanticErrorManager.semanticFatalError("Error. Linea: " + o.getLine() + ". Columna: " + o.getColumn()
		+	". La operacion \"" + o.getLexema() + "\" tiene operandos de distintos tipos:" + e1.getTipo());
} else {
	if (e1.getTipo() == "Variable"){
		SymbolVariable symbolVariable1 = (SymbolVariable) symbolTable.getSymbol(e1.getV().getId());
		TypeIF tipo1 = symbolVariable1.getType();
		if (tipo1.getName() != "BOOLEAN"){
				semanticErrorManager.semanticFatalError("Error. Linea: " + o.getLine() + ". Columna: " + o.getColumn()
					+	". La operacion \"" + o.getLexema() + "\" tiene operandos de distintos tipos:" + e1.getV().getVariable() + " - " + tipo1.getName());
		}
	}
}


/*
						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF temp1 = e1.getTemporal();
						TemporalIF temp = tf.create();
						cb.addQuadruples(e1.getIntermediateCode());
						cb.addQuadruple("NOT", temp, temp1);
						exprLogica.setTemporal(temp);
						exprLogica.setIntermediateCode(cb.create());
*/
/*			NO NIEGA
						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF temp1 = e1.getTemporal();
						TemporalIF temp = tf.create();
						cb.addQuadruples(e1.getIntermediateCode());
						cb.addQuadruple("NOT", temp, temp1);
						exprLogica.setTemporal(temp1);
						exprLogica.setIntermediateCode(cb.create());
*/

      //CÃ³digo intermedio
		ScopeIF scope = scopeManager.getCurrentScope();
        IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
        TemporalFactoryIF tf = new TemporalFactory(scope);
		TemporalIF temp1 = e1.getTemporal();
		cb.addQuadruples(e1.getIntermediateCode());
		TemporalIF temporal = tf.create();
      LabelFactoryIF lF = new LabelFactory();
      LabelIF eTrue = lF.create();
      LabelIF eFalse = lF.create();

      cb.addQuadruple("CMP", temp1, new Value(0));
      cb.addQuadruple("BNZ",eTrue);
      cb.addQuadruple("MV",temporal,new Value(1));
      cb.addQuadruple("BR",eFalse);
      cb.addQuadruple("INL",eTrue);
      cb.addQuadruple("MV",temporal,new Value(0));;
      cb.addQuadruple("INL",eFalse);
      cb.addQuadruple("MV",temp1,temporal);

	exprLogica.setTemporal(temp1);
	exprLogica.setIntermediateCode(cb.create());

						RESULT = exprLogica;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprLogica",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // exprLogica ::= expresion OR expresion 
            {
              ExprLogica RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token o = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea la expresion logica con el simbolo or
						ExprLogica exprLogica = new ExprLogica(e1, o.getLexema().toLowerCase(), e2);

ScopeIF scope1 = scopeManager.getCurrentScope();
SymbolTableIF symbolTable = scope1.getSymbolTable();
//SymbolVariable symbolVariable1 = (SymbolVariable) symbolTable.getSymbol(e1.getV().getId());
//TypeIF tipo = symbolVariable1.getType();


if (e1.getTipo() == "Aritmetica" || e2.getTipo() == "Aritmetica"){
	semanticErrorManager.semanticFatalError("Error. Linea: " + o.getLine() + ". Columna: " + o.getColumn()
		+	". La operacion \"" + o.getLexema() + "\" tiene operandos de distintos tipos:" + e1.getTipo() + " - " + e2.getTipo());
} else {
	if (e1.getTipo() == "Variable"){
		SymbolVariable symbolVariable1 = (SymbolVariable) symbolTable.getSymbol(e1.getV().getId());
		TypeIF tipo1 = symbolVariable1.getType();
		if (tipo1.getName() != "BOOLEAN"){
				semanticErrorManager.semanticFatalError("Error. Linea: " + o.getLine() + ". Columna: " + o.getColumn()
					+	". La operacion \"" + o.getLexema() + "\" tiene operandos de distintos tipos:" + e1.getV().getVariable() + " - " + tipo1.getName());
		}
	}
	if (e2.getTipo() == "Variable"){
		SymbolVariable symbolVariable2 = (SymbolVariable) symbolTable.getSymbol(e2.getV().getId());
		TypeIF tipo2 = symbolVariable2.getType();
		if (tipo2.getName() != "BOOLEAN"){
				semanticErrorManager.semanticFatalError("Error. Linea: " + o.getLine() + ". Columna: " + o.getColumn()
					+	". La operacion \"" + o.getLexema() + "\" tiene operandos de distintos tipos:" + e2.getV().getVariable() + " - " + tipo2.getName());
		}
	}	
}


						//	Codigo intermedio con evaluacion en cortocircuito
						ScopeIF scope = scopeManager.getCurrentScope();
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalFactoryIF tf = new TemporalFactory(scope);
						LabelFactoryIF lf = new LabelFactory();
						TemporalIF tempE1 = e1.getTemporal();
						TemporalIF tempE2 = e2.getTemporal();
						TemporalIF temp = tf.create();
						LabelIF label1 = lf.create();
						LabelIF label2 = lf.create();
						LabelIF label3 = lf.create();
						cb.addQuadruples(e1.getIntermediateCode());
						cb.addQuadruple("BRF", tempE1, label1);
						cb.addQuadruple("MV", temp, new Value(1));
						cb.addQuadruple("BR", label3);
						cb.addQuadruple("INL", label1);
						cb.addQuadruples(e2.getIntermediateCode());
						cb.addQuadruple("BRF", tempE2, label2);
						cb.addQuadruple("MV", temp, new Value(1));
						cb.addQuadruple("BR", label3);
						cb.addQuadruple("INL", label2);
						cb.addQuadruple("MV", temp, new Value(0));
						cb.addQuadruple("INL", label3);
						exprLogica.setTemporal(temp);
						exprLogica.setIntermediateCode(cb.create());

						RESULT = exprLogica;

/*

ScopeIF scope = scopeManager.getCurrentScope();

//Solicitamos nuevo temporal
TemporalFactory tF = new TemporalFactory(scope);

//Solicitamos el codebuilder
IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);

//Creamos el nuevo temporal
TemporalIF temp = tF.create();

//Recuperamos los temporales de las expresiones
TemporalIF temp1 = e1.getTemporal();
TemporalIF temp2 = e2.getTemporal();

//Anyadimos las cuadruplas
cb.addQuadruples(e1.getIntermediateCode());
cb.addQuadruples(e2.getIntermediateCode());
cb.addQuadruple ("OR", temp, temp1, temp2);

//Establecemos temporales y codebuilder
exprLogica.setTemporal(temp);
exprLogica.setIntermediateCode(cb.create());
//FIN CODIGO INTERMEDIO

//Propagamos la informacion del tipo de la expresion OR
RESULT=exprLogica;
*/
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprLogica",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // exprLogica ::= expresion IGUAL expresion 
            {
              ExprLogica RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token o = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea la expresion logica con el simbolo igual
						ExprLogica exprLogica = new ExprLogica(e1, o.getLexema().toLowerCase(), e2);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactory tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF tempE1 = e1.getTemporal();
						TemporalIF tempE2 = e2.getTemporal();
						TemporalIF temp = tf.create();
						cb.addQuadruples(e1.getIntermediateCode());
						cb.addQuadruples(e2.getIntermediateCode());
						cb.addQuadruple("EQ", temp, tempE1, tempE2);
						exprLogica.setTemporal(temp);
						exprLogica.setIntermediateCode(cb.create());

						RESULT = exprLogica;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprLogica",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // exprLogica ::= expresion MAYOR expresion 
            {
              ExprLogica RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token o = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea la expresion logica con el simbolo mayor
						ExprLogica exprLogica = new ExprLogica(e1, o.getLexema().toLowerCase(), e2);

/*
						//	Comprobaciones semanticas.
						//	Se comprueba que los tipos de ambas expresiones sean el mismo
						if (e1.getType().equals(e2.getType())) {
							exprLogica.setType(e1.getType());
						} else {
							semanticErrorManager.semanticFatalError("Error. Linea: " + o.getLine() + ". Columna: " + o.getColumn()	+	". La operacion \"" + o.getLexema() + "\" tiene operandos de distintos tipos.");
						}
*/

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactory tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF tempE1 = e1.getTemporal();
						TemporalIF tempE2 = e2.getTemporal();
						TemporalIF temp = tf.create();
						cb.addQuadruples(e1.getIntermediateCode());
						cb.addQuadruples(e2.getIntermediateCode());
						cb.addQuadruple("GR", temp, tempE1, tempE2);
						exprLogica.setTemporal(temp);
						exprLogica.setIntermediateCode(cb.create());

						RESULT = exprLogica;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprLogica",27, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // exprArit ::= ENTERO 
            {
              ExprArit RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token e = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea la expresion aritmetica con un entero
						ExprArit exprArit = new ExprArit(Integer.parseInt(e.getLexema().toLowerCase()));

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactory tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF temp = tf.create();
						cb.addQuadruple("MV", temp, Integer.parseInt(e.getLexema().toLowerCase()));
						exprArit.setTemporal(temp);
						exprArit.setIntermediateCode(cb.create());

						RESULT = exprArit;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprArit",26, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // exprArit ::= expresion PRODUCTO expresion 
            {
              ExprArit RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token o = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea la expresion aritmetica para multiplicaciones
						ExprArit exprArit = new ExprArit(e1, o.getLexema().toLowerCase(), e2);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactory tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF tempE1 = e1.getTemporal();
						TemporalIF tempE2 = e2.getTemporal();
						TemporalIF temp = tf.create();
						cb.addQuadruples(e1.getIntermediateCode());
						cb.addQuadruples(e2.getIntermediateCode());
						cb.addQuadruple("MUL", temp, tempE1, tempE2);
						exprArit.setTemporal(temp);
						exprArit.setIntermediateCode(cb.create());

						RESULT = exprArit;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprArit",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // exprArit ::= expresion MINUS expresion 
            {
              ExprArit RESULT =null;
		int e1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int e1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Expresion e1 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int oleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int oright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token o = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int e2left = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int e2right = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Expresion e2 = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea la expresion aritmetica para restas
						ExprArit exprArit = new ExprArit(e1, o.getLexema().toLowerCase(), e2);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactory tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF tempE1 = e1.getTemporal();
						TemporalIF tempE2 = e2.getTemporal();
						TemporalIF temp = tf.create();
						cb.addQuadruples(e1.getIntermediateCode());
						cb.addQuadruples(e2.getIntermediateCode());
						cb.addQuadruple("SUB", temp, tempE1, tempE2);
						exprArit.setTemporal(temp);
						exprArit.setIntermediateCode(cb.create());

						RESULT = exprArit;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("exprArit",26, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // expresion ::= variables 
            {
              Expresion RESULT =null;
		int vleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int vright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Variables v = (Variables)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea expresion con las variables recibidas
						Expresion expresion = new Expresion(v);
semanticErrorManager.semanticInfo("Expresion 4");

						//Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF temp = v.getTemporal();
						cb.addQuadruples(v.getIntermediateCode());
						expresion.setIntermediateCode(cb.create());
						expresion.setTemporal(temp);

						RESULT = expresion;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // expresion ::= PARENIZQ expresion PARENDER 
            {
              Expresion RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Expresion e = (Expresion)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						//	Se crea expresion con una expresion entre parentesis
						e.addE(e);
semanticErrorManager.semanticInfo("Expresion 3");
						RESULT = e;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",25, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // expresion ::= exprLogica 
            {
              Expresion RESULT =null;
		int eLleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eLright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExprLogica eL = (ExprLogica)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea expresion con una expresion logica
						Expresion expresion = new Expresion(eL);
semanticErrorManager.semanticInfo("Expresion 2");
						//Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF temp = eL.getTemporal();
						cb.addQuadruples(eL.getIntermediateCode());
						expresion.setIntermediateCode(cb.create());
						expresion.setTemporal(temp);

						RESULT = expresion;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // expresion ::= exprArit 
            {
              Expresion RESULT =null;
		int eAleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eAright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExprArit eA = (ExprArit)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea expresion con una expresion aritmetica
						Expresion expresion = new Expresion(eA);
semanticErrorManager.semanticInfo("Expresion 1");
						//Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactoryIF tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF temp = eA.getTemporal();
						cb.addQuadruples(eA.getIntermediateCode());
						expresion.setIntermediateCode(cb.create());
						expresion.setTemporal(temp);

						RESULT = expresion;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expresion",25, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // tipoRetorno ::= DOSPUNTOS error PUNTOYCOMA 
            {
              TipoRetorno RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error tipoRetorno");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoRetorno",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // tipoRetorno ::= 
            {
              TipoRetorno RESULT =null;
		
						//	Si no se recibe iOB se crea tipoRetorno vacio
						TipoRetorno tipoRetorno = new TipoRetorno();
						RESULT = tipoRetorno;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoRetorno",18, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // tipoRetorno ::= DOSPUNTOS intOBool 
            {
              TipoRetorno RESULT =null;
		int iOBleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iOBright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		IntOBool iOB = (IntOBool)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea tipoRetorno con el iOB recibido
						TipoRetorno tipoRetorno = new TipoRetorno(iOB);
						RESULT = tipoRetorno;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoRetorno",18, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // procParam ::= cadIdVar error PUNTOYCOMA 
            {
              ProcParam RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error procParam");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procParam",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // procParam ::= cadIdVar DOSPUNTOS tipoVar 
            {
              ProcParam RESULT =null;
		int cIdVleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cIdVright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		CadIdVar cIdV = (CadIdVar)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tVleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int tVright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		TipoVar tV = (TipoVar)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea procParam
						ProcParam procParam = new ProcParam(cIdV, tV);
						RESULT = procParam;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procParam",21, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // procListParam ::= 
            {
              ProcListParam RESULT =null;
		
						//	Si no hay procParam se crea procListParam vacio
						ProcListParam procListParam = new ProcListParam();
						RESULT = procListParam;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procListParam",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // procListParam ::= procParam 
            {
              ProcListParam RESULT =null;
		int pPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pPright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ProcParam pP = (ProcParam)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Si se recibe un unico procParam se crea procListParam con el
						ProcListParam procListParam = new ProcListParam(pP);
						RESULT = procListParam;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procListParam",20, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // procListParam ::= procParam PUNTOYCOMA procListParam 
            {
              ProcListParam RESULT =null;
		int pPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int pPright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ProcParam pP = (ProcParam)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int pLPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int pLPright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ProcListParam pLP = (ProcListParam)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se añade procParam a la lista de procListParam
						pLP.addPP(pP);
						RESULT = pLP;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procListParam",20, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // procParenParam ::= 
            {
              ProcParenParam RESULT =null;
		
						//	Si no se reciben datos se crea procParenParam vacio
						ProcParenParam procParenParam = new ProcParenParam();
						RESULT = procParenParam;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procParenParam",19, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // procParenParam ::= PARENIZQ procListParam PARENDER 
            {
              ProcParenParam RESULT =null;
		int pLPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int pLPright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ProcListParam pLP = (ProcListParam)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						//	Se crea procParenParam con los datos recibidos de procListParam
						ProcParenParam procParenParam = new ProcParenParam(pLP);
						RESULT = procParenParam;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("procParenParam",19, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // cabProcedure ::= PROCEDURE error 
            {
              CabProcedure RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error cabProcedure");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cabProcedure",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // cabProcedure ::= PROCEDURE IDENTIFICADOR error 
            {
              CabProcedure RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error cabProcedure");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cabProcedure",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // cabProcedure ::= PROCEDURE IDENTIFICADOR procParenParam tipoRetorno PUNTOYCOMA 
            {
              CabProcedure RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int pPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int pPright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		ProcParenParam pP = (ProcParenParam)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int tRleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tRright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		TipoRetorno tR = (TipoRetorno)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						//	Comprobaciones semanticas
						semanticErrorManager.semanticInfo("Entro declaracion de procedure");
						semanticErrorManager.semanticInfo("");
						//	Se recupera el ambito, tabla de tipos y de simbolos
						ScopeIF scope = scopeManager.getCurrentScope();
						TypeTableIF typeTable = scope.getTypeTable();
						SymbolTableIF symbolTable = scope.getSymbolTable();

						//	Se comprueba que no se este utilizando ya el id
						if(symbolTable.containsSymbol(id.getLexema().toLowerCase())){
							semanticErrorManager.semanticFatalError("Identificador " + id.getLexema() + " ya utilizado");
						}

						//	Se añade a la tabla de tipos
						TypeProcedure tP = new TypeProcedure(scope, id.getLexema().toLowerCase());
						typeTable.addType(id.getLexema().toLowerCase(), tP);

						//	Se crea cabProcedure con el nombre, ambito, procParenParam y tipoRetorno
						CabProcedure cabProcedure = new CabProcedure(id.getLexema().toLowerCase(), scope, pP, tR);
						RESULT = cabProcedure;

						SymbolIF symbol  = null;
						//	Si tiene un tipo de retorno declarado entonces se trata de una funcion y se crea el simbolo
						if(tR.getiOB() != null) {
							semanticErrorManager.semanticInfo("cabProcedure: es funcion");
							TypeFunction typeFunction = new TypeFunction(scope);
							symbol = new SymbolFunction(scope, id.getLexema().toLowerCase(), typeFunction, cabProcedure);
						//	Si el tipo de retorno es vacio entonces es un procedimiento y se crea el simbolo
						} else {
							semanticErrorManager.semanticInfo("cabProcedure: es procedimiento");
							TypeProcedure typeProcedure = new TypeProcedure(scope);
							symbol = new SymbolProcedure(scope, id.getLexema().toLowerCase(), typeProcedure, cabProcedure);
						}
                       
						//	Se añade a la tabla de simbolos el identificador junto al simbolo de funcion o procedimiento
						symbolTable.addSymbol(id.getLexema().toLowerCase(), symbol);

						//	Se crea un nuevo ambito con el nombre del procedure
						ScopeIF procedureScope = scopeManager.openScope(id.getLexema().toLowerCase());
						TypeTableIF procedureTypeTable = procedureScope.getTypeTable();
						//	Se crean y añaden los tipos simples y el tipo del procedure
						TypeSimple procedureTipeSympleInt = new TypeSimple(procedureScope,"INTEGER");
						TypeSimple procedureTipeSympleBoolean = new TypeSimple(procedureScope,"BOOLEAN");
						TypeProcedure procedureTPid = new TypeProcedure(procedureScope, id.getLexema().toLowerCase());
						procedureTypeTable.addType("INTEGER",procedureTipeSympleInt);
						procedureTypeTable.addType("BOOLEAN",procedureTipeSympleBoolean);
						procedureTypeTable.addType(id.getLexema().toLowerCase(), procedureTPid);
						semanticErrorManager.semanticInfo("Entrando en el ambito " + procedureScope.getName() + ". Nivel " + procedureScope.getLevel());

//						semanticErrorManager.semanticInfo("Opened " + procedureScope);

						//	Se añaden los simbolos a la tabla de simbolos de todos parametros
						for(ProcParam procParam : pP.getProcParams()){
							if(procParam.getcIdV()!=null){
								for(String identificadorParam : procParam.getcIdV().getListId()){
									if(scopeManager.searchSymbol(identificadorParam)==null) {
										TypeIF type = scopeManager.searchType(procParam.gettV().getId());
										SymbolParameter symbolParameter = new SymbolParameter(procedureScope, identificadorParam, type);
										procedureScope.getSymbolTable().addSymbol(symbolParameter);
									}
								}
							}
						}
						semanticErrorManager.semanticInfo("Fin declaracion procedure");
						
/*
						ExprArit exprArit = new ExprArit(e1, o.getLexema().toLowerCase(), e2);

						//	Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
						TemporalFactory tf = new TemporalFactory(scope);
						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
						TemporalIF tempE1 = e1.getTemporal();
						TemporalIF tempE2 = e2.getTemporal();
						TemporalIF temp = tf.create();
						cb.addQuadruples(e1.getIntermediateCode());
						cb.addQuadruples(e2.getIntermediateCode());
						cb.addQuadruple("MUL", temp, tempE1, tempE2);
						exprArit.setTemporal(temp);
*/
//						ScopeIF scope1 = scopeManager.getCurrentScope();
//						IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope1);
//						tP.setIntermediateCode(cb.create());

						
						
						
						semanticErrorManager.semanticInfo("");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cabProcedure",17, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // stmSubprogram ::= 
            {
              StmSubprogram RESULT =null;
		
						//	Si no hay subprogramas se crea stmSubprogram vacio
						semanticErrorManager.semanticInfo("ENTRO A STMSUBPROGRAM y esta vacio");
						StmSubprogram stmSubprogram = new StmSubprogram();
						RESULT = stmSubprogram;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmSubprogram",7, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // stmSubprogram ::= cabProcedure cuerpo stmSubprogram 
            {
              StmSubprogram RESULT =null;
		int cPleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int cPright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		CabProcedure cP = (CabProcedure)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Cuerpo c = (Cuerpo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int sSleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sSright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		StmSubprogram sS = (StmSubprogram)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se añade stmSubprogram a la lista y se itera sobre si mismo
						semanticErrorManager.semanticInfo("ENTRO A STMSUBPROGRAM y tiene cosas");
						sS.addCPc(cP, c);
						RESULT = sS;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmSubprogram",7, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // tipoVar ::= IDENTIFICADOR 
            {
              TipoVar RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea tipoVar con el identificador recibido
						TipoVar tipoVar = new TipoVar(id.getLexema().toLowerCase());
						RESULT = tipoVar;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoVar",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // tipoVar ::= intOBool 
            {
              TipoVar RESULT =null;
		int iOBleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int iOBright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		IntOBool iOB = (IntOBool)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea tipoVar con el iOB recibido
						TipoVar tipoVar = new TipoVar(iOB);
						RESULT = tipoVar;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("tipoVar",16, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // cadIdVar ::= IDENTIFICADOR 
            {
              CadIdVar RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Si solo se recibe un identificador se crea cadIdVar con el
						CadIdVar cadIdVar = new CadIdVar(id.getLexema().toLowerCase());
						RESULT = cadIdVar;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cadIdVar",15, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // cadIdVar ::= IDENTIFICADOR COMA cadIdVar 
            {
              CadIdVar RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-2)).value;
		int cIdVleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cIdVright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		CadIdVar cIdV = (CadIdVar)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se el identificador a cadIdVar y se itera sobre si mismo
						cIdV.addId(id.getLexema().toLowerCase());
						RESULT = cIdV;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cadIdVar",15, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // expVar ::= cadIdVar error PUNTOYCOMA 
            {
              ExpVar RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error expVar");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expVar",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // expVar ::= cadIdVar DOSPUNTOS tipoVar PUNTOYCOMA 
            {
              ExpVar RESULT =null;
		int cIdVleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int cIdVright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		CadIdVar cIdV = (CadIdVar)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int tVleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int tVright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		TipoVar tV = (TipoVar)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						//	Comprobaciones semanticas
						semanticErrorManager.semanticInfo("expVar");
						// Se recupera el ambito, tabla y simbolos
						ScopeIF scope = scopeManager.getCurrentScope();
						TypeTableIF typeTable = scope.getTypeTable();
						SymbolTableIF sTable = scope.getSymbolTable();

						//	Se recorre la lista de id almacenada en cadIdVar
						for (String idV:cIdV.getListId()){
							semanticErrorManager.semanticInfo("expVar: dentro del for1");

							//	Se comprueba que el id no se haya declarado anteriormente
							if(sTable.containsSymbol(idV)){
								semanticErrorManager.semanticFatalError("Identificador "+ idV + " ya utilizado");
						    }
							semanticErrorManager.semanticInfo("expVar: variable " + idV + " no declarada anteriormente");
						    
							//	Se guarda el tipo en el ambito
						    TypeIF type = null;
						    //	Se recuperan todos los ambitos creados y se recorren
							List<ScopeIF> scopes = scopeManager.getAllScopes();
							for(ScopeIF scopeT : scopes){
								//	Se busca el id en los distintos ambitos
								semanticErrorManager.semanticInfo("expVar: entro al for para buscar en todos los scopes: " + tV.getIdentificadorTipo());
								TypeTableIF typeTableF = scopeT.getTypeTable();
								type = typeTableF.getType(tV.getIdentificadorTipo());
								if (type==null) {
									semanticErrorManager.semanticInfo("expVar: Dentro de if == null");
									while(scopeT.getParentScope() != null){
										semanticErrorManager.semanticInfo("expVar: busco el tipo en el padre");
										scopeT = scopeT.getParentScope();
										typeTableF = scopeT.getTypeTable();
										type = typeTableF.getType(tV.getIdentificadorTipo());
										if(type == null){
											semanticErrorManager.semanticFatalError("WEEETipo no encontrado");
										} else {
										semanticErrorManager.semanticInfo("expVar: WEEETipo encontrado: " + type);
										}
									}
										semanticErrorManager.semanticInfo("expVar: no hay mas donde buscar");
								}
								semanticErrorManager.semanticInfo("expVar: el tipo de: " + idV + " es: " + type);
							}
							semanticErrorManager.semanticInfo("expVar: Variable: " + idV + " Ambito: " + scope + " Tipo: " + type);
							SymbolIF symbolVariable = new SymbolVariable(scope, idV, type);
							sTable.addSymbol(idV, symbolVariable);
						}
						ExpVar expVar = new ExpVar(cIdV, tV);
						RESULT = expVar;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expVar",14, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // sentVar ::= expVar 
            {
              SentVar RESULT =null;
		int eVleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eVright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpVar eV = (ExpVar)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Si solo hay una expVar se crea sentVar con ella
						SentVar sentVar = new SentVar(eV);
//						semanticErrorManager.semanticInfo("sentVar: creo la expVar");
						RESULT = sentVar;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentVar",13, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // sentVar ::= sentVar expVar 
            {
              SentVar RESULT =null;
		int sVleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sVright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		SentVar sV = (SentVar)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int eVleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eVright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpVar eV = (ExpVar)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se añade expVar a la lista de sentVar y se itera de nuevo
						sV.addEV(eV);
//						semanticErrorManager.semanticInfo("sentVar: añado la ");
						RESULT = sV;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentVar",13, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // stmVar ::= VAR error 
            {
              StmVar RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error stmVar");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmVar",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // stmVar ::= 
            {
              StmVar RESULT =null;
		
						//	Si no hay sentVar se crea stmVar vacio
						semanticErrorManager.semanticInfo("No hay variables");
						StmVar stmVar = new StmVar();
						RESULT = stmVar;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmVar",6, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // stmVar ::= VAR sentVar 
            {
              StmVar RESULT =null;
		int sVleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sVright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentVar sV = (SentVar)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea stmVar con la sentVar recibida
						semanticErrorManager.semanticInfo("A ver variables");
						StmVar stmVar = new StmVar(sV);
//						semanticErrorManager.semanticInfo("stmVar: Creada variable ");
						RESULT = stmVar;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmVar",6, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // expTipo ::= IDENTIFICADOR error PUNTOYCOMA 
            {
              ExpTipo RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error expTipo");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expTipo",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // expTipo ::= IDENTIFICADOR IGUAL ARRAY CORCHIZQ entOid PUNTOPUNTO entOid CORCHDER OF intOBool PUNTOYCOMA 
            {
              ExpTipo RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-10)).value;
		int eOid1left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int eOid1right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		EntOid eOid1 = (EntOid)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int eOid2left = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).left;
		int eOid2right = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-4)).right;
		EntOid eOid2 = (EntOid)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-4)).value;
		int iOBleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int iOBright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		IntOBool iOB = (IntOBool)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						//	Comprobaciones semanticas
						//	Se recupera el ambito y las tablas de tipos y simbolos
						ScopeIF scope = scopeManager.getCurrentScope();
						TypeTableIF typeTable = scope.getTypeTable();
						SymbolTableIF symbolTable = scope.getSymbolTable();

						//	Comprobaciones semanticas
						//	Se comprueba que no se haya utilizado ya el identificador
						if(symbolTable.containsSymbol(id.getLexema().toLowerCase())){
							semanticErrorManager.semanticFatalError("Simbolo " + id.getLexema() + " ya utilizado");
						}

						//	Se comprueba que los valores del array sean validos
						//	Se inicializan las variables para almacenar el valor de los limites inferior y superior del array
						int valor1 = -1;
						int valor2 = -1;

						//	Se almacena el valor del limite inferior del array
						//	Se recupera si esta indicado como numero entero
						if(eOid1.getTipo().equals("INTEGER")){
							semanticErrorManager.semanticInfo("eoid1 es integer");
							valor1 = eOid1.getValor();
						//	Se recupera si esta indicado mediante el uso de una constante
						} else {
							semanticErrorManager.semanticInfo("eoid1 NO es integer");
							SymbolConstant symbolEOid1 = (SymbolConstant) symbolTable.getSymbol(eOid1.getNombreId());
							valor1 = symbolEOid1.getValue();
						}

						//	Se almacena el valor del limite superior del array
						//	Se recupera si esta indicado como numero entero
						if(eOid2.getTipo().equals("INTEGER")){
							semanticErrorManager.semanticInfo("eoid2 es integer");
							valor2 = eOid2.getValor();
						//	Se recupera si esta indicado mediante el uso de una constante
						} else {
							semanticErrorManager.semanticInfo("eoid2 NO es integer");
							SymbolConstant symbolEOid2 = (SymbolConstant) symbolTable.getSymbol(eOid2.getNombreId());
							valor2 = symbolEOid2.getValue();
						}

						semanticErrorManager.semanticInfo("Valores de array 1: " + valor1);
						semanticErrorManager.semanticInfo("Valores de array 2: " + valor2);
						
						//	Se comprueba que el limite superior sea superior al limite inferior
						if (valor1 >= valor2){
							semanticErrorManager.semanticFatalError("Valores de array " + id.getLexema() + " no validos");
						} else {
							semanticErrorManager.semanticInfo("Valores de array " + id.getLexema() + " buenos");
						}
						
						//	Se crea expTipo con el nombre indicado, los limites inferior y superior y el tipo
						ExpTipo expTipo = new ExpTipo(id.getLexema().toLowerCase(), eOid1, eOid2, iOB);
						TypeIF type = new TypeArray(scope, id.getLexema().toLowerCase(), expTipo);
						typeTable.addType(id.getLexema().toLowerCase(), type);

						//	Codigo intermedio
/*
// MAGIA	NO HACE FALTA

TemporalFactory tF = new TemporalFactory(scope);
IntermediateCodeBuilder cb = new IntermediateCodeBuilder(scope);
//añadir al codigo intermedio las cuadruplas de la expresiones
cb.addQuadruples (ex.getIntermediateCode());
TemporalIF temp = tF.create();
TemporalIF temp1 = tF.create();
TemporalIF temp2 = tF.create();
TemporalIF temp3 = tF.create();
//TemporalIF tempPosicion = ex.getTemporal();
	TemporalIF tempPosicion1 = eoid1.getTemporal();
	TemporalIF tempPosicion2 = eoid2.getTemporal();
SymbolIF sV = scopeManager.searchSymbol(id.getLexema().toLowerCase());
Variable var = new Variable(id.getLexema().toLowerCase(), sV.getScope());
cb.addQuadruple("MVA", temp1, var); //dirección base de la variable
cb.addQuadruple("MV", temp2, tempPosicion1); //desplazamiento
//Sumamos el desplazamiento si la memoria va de posiciones inferiores a superiores
//si la memoria va de posiciones superiores a inferiores usamos SUB en lugar de ADD
cb.addQuadruple("ADD/SUB", temp3, temp1, temp2);
cb.addQuadruple("MVP", temp, temp3);
e.setTemporal(temp);
e.setIntermediateCode (cb.create());
//printamos el código intermedio generado (opcional)
System.out.println("Codigo intermedio: " + e.getIntermediateCode());
*/

						RESULT = expTipo;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expTipo",12, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-10)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // sentTipo ::= expTipo 
            {
              SentTipo RESULT =null;
		int eTleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eTright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpTipo eT = (ExpTipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Si hay una unica expTipo se crea la SentTipo con ella
						SentTipo sentTipo = new SentTipo(eT);
						RESULT = sentTipo;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentTipo",11, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // sentTipo ::= sentTipo expTipo 
            {
              SentTipo RESULT =null;
		int sTleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sTright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		SentTipo sT = (SentTipo)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int eTleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eTright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpTipo eT = (ExpTipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Si hay varias expTipo se añade y se itera de nuevo
						sT.addET(eT);
						RESULT = sT;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentTipo",11, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // stmTipos ::= TYPE error 
            {
              StmTipos RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error stmTipos");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmTipos",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // stmTipos ::= 
            {
              StmTipos RESULT =null;
		
						//	Si no hay sentTipo se crea stmTipos vacio
						semanticErrorManager.semanticInfo("No hay tipos");
						StmTipos stmTipos = new StmTipos();
						RESULT = stmTipos;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmTipos",5, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // stmTipos ::= TYPE sentTipo 
            {
              StmTipos RESULT =null;
		int sTleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sTright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentTipo sT = (SentTipo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea el stmTipos con la sentTipo recibida
						semanticErrorManager.semanticInfo("Vemos tipos");
						StmTipos stmTipos = new StmTipos(sT);
						RESULT = stmTipos;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmTipos",5, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // valorConst ::= vBooleano 
            {
              ValorConst RESULT =null;
		int vBleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int vBright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		VBooleano vB = (VBooleano)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea el valorConst con el booleano recibido
						ValorConst valorConst = new ValorConst(vB.getValue());
						semanticErrorManager.semanticInfo("valorConst: creo valorConst:vB: " + valorConst.getBool());
						RESULT = valorConst;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorConst",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // valorConst ::= ENTERO 
            {
              ValorConst RESULT =null;
		int eleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Token e = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Se crea el valorConst con el numero entero recibido
						ValorConst valorConst = new ValorConst(Integer.parseInt(e.getLexema().toLowerCase()));
						semanticErrorManager.semanticInfo("valorConst: creo valorConst: " + valorConst.getEntero());
						RESULT = valorConst;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("valorConst",10, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // expConst ::= IDENTIFICADOR error PUNTOYCOMA 
            {
              ExpConst RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error expConst");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expConst",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // expConst ::= IDENTIFICADOR IGUAL valorConst PUNTOYCOMA 
            {
              ExpConst RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int vCleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int vCright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		ValorConst vC = (ValorConst)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						//	Comprobaciones semanticas
						// Se recupera el ambito y la tabla de simbolos
						ScopeIF scope = scopeManager.getCurrentScope();
						SymbolTableIF symbolTable = scope.getSymbolTable();
						semanticErrorManager.semanticInfo("name: " + id.getLexema());
				
						// Se comprueba que no exista el simbolo en la tabla
						if (symbolTable.containsSymbol(id.getLexema().toLowerCase())) {
							semanticErrorManager.semanticFatalError("Constante " + id.getLexema() + " ya declarada anteriormente");
						} else {
							semanticErrorManager.semanticInfo("Bien, no se ha encontrado el id: " + id.getLexema());
						}
						
						// Se recupera el valor de la constante y se almacena en la tabla de simbolos junto a su nombre, tipo y ambito
						SymbolConstant symbolConstant;
						if (vC.getBool() != null){
							Boolean value = vC.getBool();
							TypeIF type = scopeManager.searchType("BOOLEAN");
							symbolConstant = new SymbolConstant(scope, id.getLexema().toLowerCase(), type, value);
						} else {
							int value = vC.getEntero();
							TypeIF type = scopeManager.searchType("INTEGER");
							symbolConstant = new SymbolConstant(scope, id.getLexema().toLowerCase(), type, value);
						}

						//	Se añade el identificador a la tabla de simbolos como constante
						symbolTable.addSymbol(id.getLexema().toLowerCase(), symbolConstant);
						
						//	Se crea expConst con el nombre y su valor
						ExpConst expConst = new ExpConst(id.getLexema().toLowerCase(), vC);

						String valor;
						if (vC.getBool() != null){
							valor = " " + vC.getBool();
						} else {
							valor = " " + vC.getEntero();
						}
						semanticErrorManager.semanticInfo("expConst: Creo expConst id: " + expConst.getId() + " con el valor recuperado de valorConst: " + valor);
						RESULT = expConst;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("expConst",9, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // sentConst ::= expConst 
            {
              SentConst RESULT =null;
		int eCleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eCright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpConst eC = (ExpConst)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Añado la expConst a la sentConst
						SentConst sentConst = new SentConst(eC);
						semanticErrorManager.semanticInfo("sentConst: recupero eC: " + eC.getId() + "y creo sentConst: "+ sentConst);
						RESULT = sentConst;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentConst",8, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // sentConst ::= sentConst expConst 
            {
              SentConst RESULT =null;
		int sCleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int sCright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		SentConst sC = (SentConst)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int eCleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int eCright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		ExpConst eC = (ExpConst)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Añado la expConst a la lista de sentConst y se llama a si mismo de nuevo
						sC.addEC(eC);
						semanticErrorManager.semanticInfo("sentConst: " + eC.getVC());
						RESULT = sC;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("sentConst",8, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // stmConstantes ::= CONST error 
            {
              StmConstantes RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error stmConstantes");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmConstantes",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // stmConstantes ::= 
            {
              StmConstantes RESULT =null;
		
						//	Compruebo que no hay constantes y creo StmConstantes vacio
						semanticErrorManager.semanticInfo("Entro a cuerpo de ambito: " + scopeManager.getCurrentScope());
						semanticErrorManager.semanticInfo("No hay constantes");
						StmConstantes stmConstantes = new StmConstantes();
						RESULT = stmConstantes;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmConstantes",4, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // stmConstantes ::= CONST sentConst 
            {
              StmConstantes RESULT =null;
		int sCleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int sCright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		SentConst sC = (SentConst)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						//	Compruebo que hay constantes y creo StmConstantes
						semanticErrorManager.semanticInfo("Entro a cuerpo de ambito: " + scopeManager.getCurrentScope());
						semanticErrorManager.semanticInfo("A continuacion constantes");
						StmConstantes stmConstantes = new StmConstantes(sC);
						semanticErrorManager.semanticInfo("stmConstantes: id recupero sentConst: ");
						RESULT = stmConstantes;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("stmConstantes",4, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // cuerpo ::= stmConstantes stmTipos stmVar stmSubprogram BEGIN error 
            {
              Cuerpo RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error cuerpo");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // cuerpo ::= stmConstantes stmTipos stmVar stmSubprogram BEGIN sentencias END error 
            {
              Cuerpo RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error cuerpo 2");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // cuerpo ::= stmConstantes stmTipos stmVar stmSubprogram BEGIN sentencias END IDENTIFICADOR PUNTOYCOMA 
            {
              Cuerpo RESULT =null;
		int sCleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).left;
		int sCright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)).right;
		StmConstantes sC = (StmConstantes)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-8)).value;
		int sTleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).left;
		int sTright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-7)).right;
		StmTipos sT = (StmTipos)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-7)).value;
		int sVleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).left;
		int sVright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-6)).right;
		StmVar sV = (StmVar)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-6)).value;
		int sSleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).left;
		int sSright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-5)).right;
		StmSubprogram sS = (StmSubprogram)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-5)).value;
		int sleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).left;
		int sright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-3)).right;
		Sentencias s = (Sentencias)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-3)).value;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						semanticErrorManager.semanticInfo("Entro a cuerpo 1");
						//	Creo el cuerpo con todos los datos del programa o subprograma
						Cuerpo cuerpo = new Cuerpo(sC, sT, sV, sS, s, id.getLexema().toLowerCase());


//Codigo intermedio
						ScopeIF scope = scopeManager.getCurrentScope();
TemporalFactoryIF tf = new TemporalFactory(scope);
                  
IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scope);
//	cb.addQuadruples(sS.getIntermediateCode());
cb.addQuadruples(s.getIntermediateCode());
cuerpo.setIntermediateCode(cb.create());


						//	Se cierran los ambitos abiertos
						if (scopeManager.getCurrentScope().getLevel()!=0){
							semanticErrorManager.semanticInfo("Cerrando Scope: " + scopeManager.getCurrentScope());
							scopeManager.closeScope();
						}
//						scopeManager.closeScope();

//List intermediateCode = s.getIntermediateCode ();
//	System.out.println(intermediateCode);

//for (QuadrupleIF q : intermediateCode){
//	System.out.println(q);
//}

System.out.println("Empezamos a sacar el intermedio");
/*
semanticErrorManager.semanticInfo("Imprimo CI sc:");
List intermediateSc = sC.getIntermediateCode ();
System.out.println(intermediateSc);

semanticErrorManager.semanticInfo("Imprimo CI st:");
List intermediateSt = sT.getIntermediateCode ();
System.out.println(intermediateSt);

semanticErrorManager.semanticInfo("Imprimo CI sv:");
List intermediateSv = sV.getIntermediateCode ();
System.out.println(intermediateSv);

semanticErrorManager.semanticInfo("Imprimo CI ss:");
List intermediateSs = sS.getIntermediateCode ();
System.out.println(intermediateSs);
*/

semanticErrorManager.semanticInfo("Imprimo CI s:");
List intermediateS = s.getIntermediateCode ();
/*for (QuadrupleIF q : intermediateS){
	System.out.println(q);
}
*/
System.out.println(intermediateS);

System.out.println("Fin del intermedio");


						RESULT = cuerpo;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cuerpo",3, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-8)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // cabModule ::= MODULE error 
            {
              CabModule RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error cabModule");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cabModule",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // cabModule ::= MODULE IDENTIFICADOR PUNTOYCOMA 
            {
              CabModule RESULT =null;
		int idleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int idright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Token id = (Token)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		
						semanticErrorManager.semanticInfo("Inicio de programa");
						//	Se crea el ambito global y se recupera la tabla de simbolos
						scopeManager.openScope("Global");
						ScopeIF scope = scopeManager.getCurrentScope();
						TypeTableIF typeTable = scope.getTypeTable();
						//	Se crean y guardan en el ambito los tipos entero, booleano e id del programa
						TypeSimple tipeSympleInt = new TypeSimple(scope,"INTEGER");
						TypeSimple tipeSympleBoolean = new TypeSimple(scope,"BOOLEAN");
						TypeProcedure tPid = new TypeProcedure(scope, id.getLexema().toLowerCase());
						typeTable.addType("INTEGER",tipeSympleInt);
						typeTable.addType("BOOLEAN",tipeSympleBoolean);
						typeTable.addType(id.getLexema().toLowerCase(), tPid);
						semanticErrorManager.semanticInfo("Entrando en el ambito " + scope.getName() + ". Nivel " + scope.getLevel());

						//	Creo cabModule con el id del programa
						CabModule cabModule = new CabModule(id.getLexema().toLowerCase());
						semanticErrorManager.semanticInfo("Programa creado");
						semanticErrorManager.semanticInfo("");
						RESULT = cabModule;
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("cabModule",2, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-2)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // axiom ::= cabModule error 
            {
              Axiom RESULT =null;
		
						semanticErrorManager.semanticFatalError("Error axiom");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // axiom ::= cabModule cuerpo 
            {
              Axiom RESULT =null;
		int cMleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int cMright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		CabModule cM = (CabModule)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int cleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int cright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Cuerpo c = (Cuerpo)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
						semanticErrorManager.semanticInfo("Estoy en axiom");
/*						semanticErrorManager.semanticInfo("Vamos a ver constantes");
						List<ExpConst> listEC = c.getsC().getSC().getListEC();
						for(ExpConst expConst : listEC){
							if(expConst.getVC().getBool() != null){
								semanticErrorManager.semanticInfo("Id: " + expConst.getId() + " valor: " + expConst.getVC().getBool());
							} else {
								semanticErrorManager.semanticInfo("Id: " + expConst.getId() + " valor: " + expConst.getVC().getEntero());
							}
						}
						semanticErrorManager.semanticInfo("Fin de las constantes");

						semanticErrorManager.semanticInfo("");

						semanticErrorManager.semanticInfo("Vamos a ver variables");
						List<ExpVar> listEV = c.getsV().getsV().getListEV();
						for(ExpVar expVar : listEV){
							TipoVar tipoVar = expVar.gettV();
							CadIdVar cadIdVar = expVar.getcIdV();
							String tipo = tipoVar.getIdentificadorTipo();
//							semanticErrorManager.semanticInfo("De tipo: " + tipo + " existen las siguientes variables:");
							List<String> listId = cadIdVar.getListId();
							for (String idV : listId){
								semanticErrorManager.semanticInfo("Variable: " + idV + " de tipo: " + tipo);
							}
						}
						semanticErrorManager.semanticInfo("Fin de las variables"); 
*/
//						semanticErrorManager.semanticInfo("Cerrando Scope: " + scopeManager.getCurrentScope());
//						scopeManager.closeScope();
				  		List intermediateCode1 = cM.getIntermediateCode ();
				  		List intermediateCode2 = c.getIntermediateCode ();
				  		
						semanticErrorManager.semanticInfo("Imprimo CI:");
//				  		for (QuadrupleIF q : intermediateCode1) {
//				  			System.out.println(q);
//				  		}
List intermediateCod1 = cM.getIntermediateCode ();
	System.out.println(intermediateCod1);
						semanticErrorManager.semanticInfo("Imprimo CI2:");
List intermediateCod2 = c.getIntermediateCode ();
	System.out.println(intermediateCod2);
semanticErrorManager.semanticInfo("Impreso CI2:");
	

//											ROB

Axiom axiom =  new Ax(cM, c);
LabelFactoryIF labelFactory = new LabelFactory ();
LabelIF label = labelFactory.create(cM.getId());

axiom.setLabel(label);

TypeIF type = scopeManager.searchType(cM.getId());
if(scopeManager.getCurrentScope().getLevel()!=0){
	for (SymbolIF symbol : scopeManager.getCurrentScope().getSymbolTable().getSymbols()) {
		((TypeProcedure) type).incSize(symbol.getType().getSize());
	}
}

((TypeProcedure) type).incSize(scopeManager.getCurrentScope().getTemporalTable().getTemporals().size());

//Codigo intermedio
boolean labelAdded = false;
TemporalFactoryIF tf = new TemporalFactory(scopeManager.getCurrentScope());
IntermediateCodeBuilderIF cb = new IntermediateCodeBuilder(scopeManager.getCurrentScope());
LabelIF labelFin = labelFactory.create("F_MAIN");
						semanticErrorManager.semanticInfo("Corta 1");
if (c.getS().getlS() == null){
	semanticErrorManager.semanticInfo("Es null");
	cb.addQuadruple("INL", label, 0);
} else {
	semanticErrorManager.semanticInfo("No es null");
	for (Sentencia procedure : c.getS().getlS().getListS()) {
		semanticErrorManager.semanticInfo("Entra for");
		if(!labelAdded){
			cb.addQuadruple("INL", label, 0);
			labelAdded = true;
		} 
		cb.addQuadruples(procedure.getIntermediateCode());
	}
}
						semanticErrorManager.semanticInfo("Corta 2");
cb.addQuadruple("BR", labelFin);
cb.addQuadruples(c.getsS().getIntermediateCode());
cb.addQuadruple("INL", labelFin, 0);
axiom.getIntermediateCode().addAll(cb.create());
ScopeIF scope = scopeManager.getCurrentScope();
						semanticErrorManager.semanticInfo("Corta 3");
if(scope!=null){
	scopeManager.closeScope();
}
						semanticErrorManager.semanticInfo("Corta 4");
RESULT = axiom;

					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("axiom",1, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // program ::= NT$0 axiom 
            {
              Object RESULT =null;
              // propagate RESULT from NT$0
                RESULT = (Object) ((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		int axleft = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).left;
		int axright = ((java_cup.runtime.Symbol)CUP$parser$stack.peek()).right;
		Axiom ax = (Axiom)((java_cup.runtime.Symbol) CUP$parser$stack.peek()).value;
		
				  		// No modificar esta estructura, aunque se pueden aÃ±adir mÃ¡s acciones semÃ¡nticas
				  		
				  		//List intermediateCode = ax.getIntermediateCode ();
				  		//finalCodeFactory.create (intermediateCode);
					
						// En caso de no comentarse las dos sentencias anteriores puede generar una excepcion
						// en las llamadas a cupTest si el compilador no estÃ¡ completo. Esto es debido a que 
						// aÃºn no se tendrÃ¡ implementada la generaciÃ³n de cÃ³digo intermedio ni final.
						// Para la entrega final deberÃ¡n descomentarse y usarse.

						int globalAddress = 0;
						int globalOffset = 0;
						ScopeIF currentScope = null;
						Map<String, SymbolProcedure> procedures = new HashMap<String, SymbolProcedure>();
						for (ScopeIF scope : scopeManager.getAllScopes()) {        
semanticErrorManager.semanticInfo("Corta 5");
							int scopeOffset = 0;
							int functionOffset = 1;
							boolean scopeGlobal = false;
							for(SymbolIF symbol : scope.getSymbolTable().getSymbols()) {
semanticErrorManager.semanticInfo("Corta 6");
								if(symbol instanceof SymbolVariable) {
									SymbolVariable variableSymbol = (SymbolVariable)symbol;
									if (scope.getLevel() == 0) {
semanticErrorManager.semanticInfo("Corta 7");
										variableSymbol.setAddress(globalAddress);
										globalAddress += variableSymbol.getType().getSize();
									} else {						
semanticErrorManager.semanticInfo("Corta 8");
										variableSymbol.setAddress(functionOffset); // Ademas de la dir de retorno se reserva espacio para el estado y el enlace de control
										functionOffset += variableSymbol.getType().getSize();
										SymbolProcedure function = (SymbolProcedure) procedures.get(variableSymbol.getScope().getName());
										function.incrementSize(variableSymbol.getType().getSize());
										function.incrementTempSize(variableSymbol.getType().getSize());
										variableSymbol.setEnclosingSymbol(function);
									}
semanticErrorManager.semanticInfo("Corta 14");
								} else if (symbol instanceof SymbolFunction) {
semanticErrorManager.semanticInfo("Corta 15");
									procedures.put(symbol.getName(), (SymbolFunction)symbol);
								} else if (symbol instanceof SymbolProcedure) {
semanticErrorManager.semanticInfo("Corta 16");
									procedures.put(symbol.getName(), (SymbolProcedure)symbol);
								} else if (symbol instanceof SymbolParameter) {
/*semanticErrorManager.semanticInfo("Corta 17");
									SymbolParameter parametro = (SymbolParameter)symbol;
semanticErrorManager.semanticInfo("Corta 19");
									parametro.setAddress(scopeOffset);
semanticErrorManager.semanticInfo("Corta 20");
scopeOffset = scopeOffset;
semanticErrorManager.semanticInfo("Corta 31");
TypeIF pruebaTipo = parametro.getType();
semanticErrorManager.semanticInfo(pruebaTipo);
semanticErrorManager.semanticInfo("Corta 33");
int prueba = parametro.getType().getSize();
semanticErrorManager.semanticInfo("Corta 32");
									scopeOffset += parametro.getType().getSize();
semanticErrorManager.semanticInfo("Corta 21");
									SymbolProcedure function = (SymbolProcedure)procedures.get(parametro.getScope().getName());
semanticErrorManager.semanticInfo("Corta 22");
									function.incrementSize(parametro.getType().getSize());
semanticErrorManager.semanticInfo("Corta 23");
									parametro.setEnclosingSymbol(function);
semanticErrorManager.semanticInfo("Corta 18");
*/								}
							}

semanticErrorManager.semanticInfo("Corta 9");
							List<TemporalIF> temporalesAmbito = scope.getTemporalTable().getTemporals();
semanticErrorManager.semanticInfo("Corta 10");
							for (TemporalIF t:temporalesAmbito) {
								if (scope.getLevel() == 0) {
									t.setAddress(scopeOffset);
									scopeOffset++;
								} else {
									t.setAddress(functionOffset);
									SymbolProcedure function = (SymbolProcedure)procedures.get(t.getScope().getName());
									function.incrementSize();
									((Temporal)t).setEnclosingSymbol(function);
									function.incrementTempSize();
									functionOffset++;
								}
							}
semanticErrorManager.semanticInfo("Corta 11");
							if (scope.getLevel() == 0) {
semanticErrorManager.semanticInfo("Corta 12");
								currentScope = scope;
								globalOffset = scopeOffset;
							}
						}
semanticErrorManager.semanticInfo("Corta 13");
						IntermediateCodeBuilder cb = new IntermediateCodeBuilder(currentScope);
						LabelFactoryIF labelFactory = new LabelFactory ();
						cb.addQuadruple("DATA", null, globalAddress + globalOffset, globalAddress);
						cb.addQuadruple("BR", ax.getLabel());
						cb.addQuadruples(ax.getIntermediateCode());
						cb.addQuadruple("HALT");
			cb.addQuadruples(listaCadenas);
						finalCodeFactory.setEnvironment(new ExecutionEnvironmentEns2001());
						finalCodeFactory.create(cb.create());
						syntaxErrorManager.syntaxInfo ("Codigo intermedio generado; \n  ");
						for (QuadrupleIF q:cb.create()) {
							syntaxErrorManager.syntaxInfo (q.toString());
						}
						syntaxErrorManager.syntaxInfo ("Parsing process ended.");
					
              CUP$parser$result = parser.getSymbolFactory().newSymbol("program",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // NT$0 ::= 
            {
              Object RESULT =null;
 
							syntaxErrorManager.syntaxInfo ("Starting parsing..."); 
						
              CUP$parser$result = parser.getSymbolFactory().newSymbol("NT$0",44, ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          return CUP$parser$result;

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= program EOF 
            {
              Object RESULT =null;
		int start_valleft = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).left;
		int start_valright = ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)).right;
		Object start_val = (Object)((java_cup.runtime.Symbol) CUP$parser$stack.elementAt(CUP$parser$top-1)).value;
		RESULT = start_val;
              CUP$parser$result = parser.getSymbolFactory().newSymbol("$START",0, ((java_cup.runtime.Symbol)CUP$parser$stack.elementAt(CUP$parser$top-1)), ((java_cup.runtime.Symbol)CUP$parser$stack.peek()), RESULT);
            }
          /* ACCEPT */
          CUP$parser$parser.done_parsing();
          return CUP$parser$result;

          /* . . . . . .*/
          default:
            throw new Exception(
               "Invalid action number found in internal parse table");

        }
    }
}

